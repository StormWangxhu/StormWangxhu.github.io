<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F31%2Fzookeeper%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[zookeeper安装下载官方网站 安装将下载下来的安装包移动了我的软件目录下：/usr/local/software/，并解压 1sudo tar -zxvf zookeeper-3.4.13\ .tar.gz 修改环境变量123sudo gedit /etc/profileexport ZOOKEEPER_HOME=/usr/local/software/zookeeper-3.4.13export PATH=$PATH:$ZOOKEEPER_HOME/bin 使其生效1source /etc/profile 修改zookeeper配置文件123cd zookeeper-3.4.1.3/confsudo cp zoo_sample.cfg zoo.cfgsudo gedit zoo.cfg 添加内容1234dataDir=/home/stormwangxhu/export/data/zkdataserver.1=mimi1:2888:3888server.2=mimi1:2888:3888server.3=mimi1:2888:3888 创建文件夹123cd /home/stormwangxhu/export/datasudo -i 进入root权限vim myid （写入1并保存） 启动zookeeper123cd /usr/local/software/zookeeper-3.4.13/binzkServer.sh start //启动zkServer.sh status //查看状态]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F04%2FJava%20%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[一、运行时数据区域 程序计数器 Java 虚拟机栈 本地方法栈 堆 方法区 运行时常量池 直接内存 二、垃圾收集 判断一个对象是否可被回收 引用类型 垃圾收集算法 垃圾收集器 三、内存分配与回收策略 Minor GC 和 Full GC 内存分配策略 Full GC 的触发条件 四、类加载机制 类的生命周期 类加载过程 类初始化时机 类与类加载器 类加载器分类 双亲委派模型 自定义类加载器实现 参考资料 一、运行时数据区域 程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 Java 虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小： 1java -Xss512M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 本地方法栈本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 堆所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation） 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava 方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 运行时常量池运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 直接内存在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存（Native 堆），然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 二、垃圾收集垃圾收集主要是针对堆和方法区进行。 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。 判断一个对象是否可被回收1. 引用计数算法给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011public class ReferenceCountingGC &#123; public Object instance = null; public static void main(String[] args) &#123; ReferenceCountingGC objectA = new ReferenceCountingGC(); ReferenceCountingGC objectB = new ReferenceCountingGC(); objectA.instance = objectB; objectB.instance = objectA; &#125;&#125; 2. 可达性分析算法通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 3. 方法区的回收因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 4. finalize()finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。 引用类型无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 1. 强引用被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 2. 软引用被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3. 弱引用被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来实现弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 4. 虚引用又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 使用 PhantomReference 来实现虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj = null; 垃圾收集算法1. 标记 - 清除 标记要回收的对象，然后清除。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 2. 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 4. 分代收集现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 1. Serial 收集器 Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 模式下的默认新生代收集器，因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2. ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。 3. Parallel Scavenge 收集器与 ParNew 一样是多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 4. Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7. G1 收集器G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 三、内存分配与回收策略Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 内存分配策略1. 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 2. 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 3. 长期存活的对象进入老年代为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 4. 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 5. 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 1. 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 2. 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 3. 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。 4. JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 5. Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 四、类加载机制类是在运行期间第一次使用时动态加载的，而不是编译时期一次性加载。因为如果在编译时期一次性加载，那么会占用很多的内存。 类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 1. 加载加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 2. 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 3. 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。 注意，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。 1public static final int value = 123; 4. 解析将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 5. 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt;clinit&gt;() 方法具有以下特点： 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行 &lt;clinit&gt;() 方法的类肯定为 java.lang.Object。 由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 2&#125; &lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 &lt;clinit&gt;() 方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 类初始化时机1. 主动引用虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 2. 被动引用以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类与类加载器两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分； 所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 1. 工作过程一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载。 2. 好处使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。 3. 实现以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader &#123; // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125;&#125; 自定义类加载器实现FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + ".class"; &#125;&#125; 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. Chapter 2. The Structure of the Java Virtual Machine Jvm memoryGetting Started with the G1 Garbage Collector JNI Part1: Java Native Interface Introduction and “Hello World” application Memory Architecture Of JVM(Runtime Data Areas) JVM Run-Time Data Areas Android on x86: Java Native Interface and the Android Native Development Kit 深入理解 JVM(2)——GC 算法与内存分配策略 深入理解 JVM(3)——7 种垃圾收集器 JVM Internals 深入探讨 Java 类加载器 Guide to WeakHashMap in Java Tomcat example source code file (ConcurrentCache.java)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F12%2F04%2FLinux%2F</url>
    <content type="text"><![CDATA[一、常用操作以及概念 快捷键 求助 关机 PATH sudo 包管理工具 发行版 VIM 三个模式 GNU 开源协议 二、磁盘 磁盘接口 磁盘的文件名 三、分区 分区表 开机检测程序 四、文件系统 分区与文件系统 组成 文件读取 磁盘碎片 block inode 目录 日志 挂载 目录配置 五、文件 文件属性 文件与目录的基本操作 修改权限 文件默认权限 目录的权限 链接 获取文件内容 指令与文件搜索 六、压缩与打包 压缩文件名 压缩指令 打包 七、Bash 特性 变量操作 指令搜索顺序 数据流重定向 八、管道指令 提取指令 排序指令 双向输出重定向 字符转换指令 分区指令 九、正则表达式 grep printf awk 十、进程管理 查看进程 进程状态 SIGCHLD wait() waitpid() 孤儿进程 僵尸进程 参考资料 一、常用操作以及概念快捷键 Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF） 求助1. –help指令的基本用法与选项介绍。 2. manman 是 manual 的缩写，将指令的具体信息显示出来。 当执行man date时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下： 代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. infoinfo 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。 4. doc/usr/share/doc 存放着软件的一整套说明文件。 关机1. who在关机前需要先使用 who 命令查看有没有其它用户在线。 2. sync为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。 3. shutdown12345# shutdown [-krhc] 时间 [信息]-k ： 不会关机，只是发送警告信息，通知所有在线的用户-r ： 将系统的服务停掉后就重新启动-h ： 将系统的服务停掉后就立即关机-c ： 取消已经在进行的 shutdown 指令内容 PATH可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 1/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin sudosudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。 包管理工具RPM 和 DPKG 为最常见的两类软件包管理工具： RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。 与 RPM 进行竞争的是基于 Debian 操作系统 (Ubuntu) 的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。 YUM 基于 RPM，具有依赖管理功能，并具有软件升级的功能。 发行版Linux 发行版是 Linux 内核及各种应用软件的集成版本。 基于的包管理工具 商业发行版 社区发行版 RPM Red Hat Fedora / CentOS DPKG Ubuntu Debian VIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 GNUGNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议，包含了以下内容： 以任何目的运行此程序的自由； 再复制的自由； 改进此程序，并公开发布改进的自由。 开源协议 Choose an open source license 如何选择开源许可证？ 二、磁盘磁盘接口1. IDEIDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。 2. SATASATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MiB/s，而新的 SATA-III 标准可达到 600MiB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。 3. SCSISCSI 全称是 Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的 SCSI-II 到目前的 Ultra320 SCSI 以及 Fiber-Channel（光纤通道），接口型式也多种多样。SCSI 硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。 4. SASSAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也透过缩小连接线改善系统内部空间等。 磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下： IDE 磁盘：/dev/hd[a-d] SATA/SCSI/SAS 磁盘：/dev/sd[a-p] 其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。 三、分区分区表磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。 1. MBRMBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。 2. GPT不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。 GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。 GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。 MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。 开机检测程序1. BIOSBIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。 BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。 主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。 安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。 2. UEFIBIOS 不可以读取 GPT 分区表，而 UEFI 可以。 四、文件系统分区与文件系统对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。 组成最主要的几个组成部分如下： inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号； block：记录文件的内容，文件太大时，会占用多个 block。 除此之外还包括： superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； block bitmap：记录 block 是否被使用的位域。 文件读取对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。 磁盘碎片指一个文件内容所在的 block 过于分散。 block在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。 大小 1KB 2KB 4KB 最大单一文件 16GB 256GB 2TB 最大文件系统 2TB 8TB 16TB 一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。 inodeinode 具体包含以下信息： 权限 (read/write/excute)； 拥有者与群组 (owner/group)； 容量； 建立或状态改变的时间 (ctime)； 最近一次的读取时间 (atime)； 最近修改的时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID…； 该文件真正内容的指向 (pointer)。 inode 具有以下特点： 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)； 每个文件都仅会占用一个 inode。 inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。 目录建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。 可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。 日志如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。 ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。 挂载挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。 目录配置为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： / (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程序运行过程中的数据文件。 五、文件文件属性用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作1. ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 1234# ls [-aAdfFhilnrRSt] file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cd更换当前目录。 1cd [相对路径或绝对路径] 3. mkdir创建目录。 123# mkdir [-mp] 目录名称-m ：配置目录权限-p ：递归创建目录 4. rmdir删除目录，目录必须为空。 12rmdir [-p] 目录名称-p ：递归删除目录 5. touch更新文件时间或者建立新文件。 123456# touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp复制文件。 如果源文件有两个以上，则目的文件一定要是目录才行。 12345678cp [-adfilprsu] source destination-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm删除文件。 12# rm [-fir] 文件或目录-r ：递归删除 8. mv移动文件。 123# mv [-fiu] source destination# mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 1# chmod [-R] xyz dirname/filename 示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 1# chmod 754 .bashrc 也可以使用符号来设定权限。 12345678# chmod [ugoa] [+-=] [rwx] dirname/filename- u：拥有者- g：所属群组- o：其他人- a：所有人- +：添加权限- -：移除权限- =：设定权限 示例：为 .bashrc 文件的所有用户添加写权限。 1# chmod a+w .bashrc 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。 目录的权限文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。 链接123# ln [-sf] source_filename dist_filename-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件 1. 实体链接在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越文件系统、不能对目录进行链接。 1234# ln /etc/crontab .# ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 可以为目录建立链接。 123# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 获取文件内容1. cat取得文件内容。 12# cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac是 cat 的反向操作，从最后一行开始打印。 3. more和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 4. less和 more 类似，但是多了一个向前翻页的功能。 5. head取得文件前几行。 12# head [-n number] filename-n ：后面接数字，代表显示几行的意思 6. tail是 head 的反向操作，只是取得是后几行。 7. od以字符或者十六进制的形式显示二进制文件。 指令与文件搜索1. which指令搜索。 12# which [-a] command-a ：将所有指令列出，而不是只列第一个 2. whereis文件搜索。速度比较快，因为它只搜索几个特定的目录。 1# whereis [-bmsu] dirname/filename 3. locate文件搜索。可以用关键字或者正则表达式进行搜索。 locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 12# locate [-ir] keyword-r：正则表达式 4. find文件搜索。可以使用文件的属性和权限进行搜索。 12# find [basedir] [option]example: find . -name "shadow*" ① 与时间有关的选项 1234-mtime n ：列出在 n 天前的那一天修改过内容的文件-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件-newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下： ② 与文件拥有者和所属群组有关的选项 123456-uid n-gid n-user name-group name-nouser ：搜索拥有者不存在 /etc/passwd 的文件-nogroup：搜索所属群组不存在于 /etc/group 的文件 ③ 与文件权限和名称有关的选项 123456-name filename-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE-perm mode ：搜索权限等于 mode 的文件-perm -mode ：搜索权限包含 mode 的文件-perm /mode ：搜索权限包含任一 mode 的文件 六、压缩与打包压缩文件名Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 压缩指令1. gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 123456$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 12$ bzip2 [-cdkzv#] filename-k ：保留源文件 3. xz提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。 123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩-z ：使用 zip；-j ：使用 bzip2；-J ：使用 xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 七、Bash可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 特性 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab 命名别名：例如 lm 是 ls -al 的别名 shell scripts 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 变量操作对一个变量赋值直接使用 =。 对变量取用需要在变量前加上 \$ ，也可以用 \${} 的形式； 输出变量使用 echo 命令。 123$ x=abc$ echo $x$ echo $&#123;x&#125; 变量内容如果有空格，必须使用双引号或者单引号。 双引号内的特殊字符可以保留原本特性，例如 x=”lang is \$LANG”，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x=’lang is \$LANG’，则 x 的值为 lang is \$LANG。 可以使用 `指令` 或者 \$(指令) 的方式将指令的执行结果赋值给变量。例如 version=\$(uname -r)，则 version 的值为 4.15.0-22-generic。 可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令： 12345$ declare [-aixr] variable-a ： 定义为数组类型-i ： 定义为整数类型-x ： 定义为环境变量-r ： 定义为 readonly 类型 使用 [ ] 来对数组进行索引操作： 123$ array[1]=a$ array[2]=b$ echo $&#123;array[1]&#125; 指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内置的指令来执行； 按 \$PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 1$ find /home -name .bashrc &gt; list 2&gt;&amp;1 八、管道指令管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。 在命令之间使用 | 分隔各个管道命令。 1$ ls -al /etc | less 提取指令cut 对数据进行切分，取出想要的部分。 切分过程一行一行地进行。 1234$ cut-d ：分隔符-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间-c ：以字符为单位取出区间 示例 1：last 显示登入者的信息，取出用户名。 123456$ lastroot pts/1 192.168.201.101 Sat Feb 7 12:35 still logged inroot pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)$ last | cut -d ' ' -f 1 示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。 12345678$ exportdeclare -x HISTCONTROL="ignoredups"declare -x HISTSIZE="1000"declare -x HOME="/home/dmtsai"declare -x HOSTNAME="study.centos.vbird".....(其他省略).....$ export | cut -c 12- 排序指令sort 用于排序。 123456789$ sort [-fbMnrtuk] [file or stdin]-f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN，DEC-n ：使用数字-r ：反向排序-u ：相当于 unique，重复的内容只出现一次-t ：分隔符，默认为 tab-k ：指定排序的区间 示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。 12345$ cat /etc/passwd | sort -t ':' -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。 123$ uniq [-ic]-i ：忽略大小写-c ：进行计数 示例：取得每个人的登录总次数 1234567$ last | cut -d ' ' -f 1 | sort | uniq -c16 (unknown47 dmtsai4 reboot7 root1 wtmp 双向输出重定向输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 1$ tee [-a] file 字符转换指令tr 用来删除一行中的字符，或者对字符进行替换。 12$ tr [-ds] SET1 ...-d ： 删除行中 SET1 这个字符串 示例，将 last 输出的信息所有小写转换为大写。 1$ last | tr '[a-z]' '[A-Z]' col 将 tab 字符转为空格字符。 12$ col [-xb]-x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。 12$ expand [-t] file-t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。 12345$ join [-ti12] file1 file2-t ：分隔符，默认为空格-i ：忽略大小写的差异-1 ：第一个文件所用的比较字段-2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。 12$ paste [-d] file1 file2-d ：分隔符，默认为 tab 分区指令split 将一个文件划分成多个文件。 1234$ split [-bl] file PREFIX-b ：以大小来进行分区，可加单位，例如 b, k, m 等-l ：以行数来进行分区。- PREFIX ：分区文件的前导名称 九、正则表达式grepg/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 123456$ grep [-acinv] [--color=auto] 搜寻字符串 filename-c ： 统计个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 123456$ grep -n 'the' regular_express.txt8:I can't finish the test.12:the symbol '*' is represented as start.15:You are the best is mean you are the no. 1.16:The world Happy is the same with "glad".18:google is the best tools for search keyword 因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt printf用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 1234$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。 awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：\$n，n 为字段号，从 1 开始，\$0 表示一整行。 示例：取出最近五个登录用户的用户名和 IP 123456$ last -n 5dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged indmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) 1$ last -n 5 | awk '&#123;print $1 "\t" $3&#125;' 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。 1$ awk '条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...' filename 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 1234$ cat /etc/passwd | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;root 0bin 1daemon 2 awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段 123456$ last -n 5 | awk '&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9 十、进程管理查看进程1. ps查看某个时间点的进程信息 示例一：查看自己的进程 1# ps -l 示例二：查看系统所有进程 1# ps aux 示例三：查看特定的进程 1# ps aux | grep threadx 2. pstree查看进程树 示例：查看所有进程树 1# pstree -A 3. top实时显示进程信息 示例：两秒钟刷新一次 1# top -d 2 4. netstat查看占用端口的进程 示例：查看特定端口的进程 1# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue) D uninterruptible sleep (usually I/O) S interruptible sleep (waiting for an event to complete) Z zombie (terminated but not reaped by its parent) T stopped (either by a job control signal or because it is being traced) SIGCHLD当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中： 得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。 在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。 wait()1pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。 如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。 参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。 waitpid()1pid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。 pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。 options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 参考资料 鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009. Linux 平台上的软件包管理 Linux 之守护进程、僵死进程与孤儿进程 What is the difference between a symbolic link and a hard link? Linux process states GUID Partition Table 详解 wait 和 waitpid 函数 IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍 Akai IB-301S SCSI Interface for S2800,S3000 Parallel ATA ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed Decoding UCS Invicta – Part 1 硬盘 Difference between SAS and SATA BIOS File system design case studies Programming Project #4 FILE SYSTEM DESIGN]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL%2F</url>
    <content type="text"><![CDATA[一、索引 B+ Tree 原理 MySQL 索引 索引优化 索引的优点 索引的使用条件 二、查询性能优化 使用 Explain 进行分析 优化数据访问 重构查询方式 三、存储引擎 InnoDB MyISAM 比较 四、数据类型 整型 浮点数 字符串 时间和日期 五、切分 水平切分 垂直切分 Sharding 策略 Sharding 存在的问题 六、复制 主从复制 读写分离 参考资料 一、索引B+ Tree 原理1. 数据结构B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。 B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。 在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。 2. 操作进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。 3. 与红黑树的比较红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： （一）更少的查找次数 平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。 （二）利用磁盘预读特性 为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。 操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。 MySQL 索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 1. B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 2. 哈希索引哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 3. 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 4. 空间数据索引MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 索引优化1. 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 3. 索引列的顺序让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 4. 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 对于前缀长度的选取需要根据索引选择性来确定。 5. 覆盖索引索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 二、查询性能优化使用 Explain 进行分析Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 优化数据访问1. 减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 2. 减少服务器端扫描的行数最有效的方式是使用索引来覆盖查询。 重构查询方式1. 切分大查询一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( "DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")&#125; while rows_affected &gt; 0 2. 分解大连接查询将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 1234SELECT * FROM tabJOIN tag_post ON tag_post.tag_id=tag.idJOIN post ON tag_post.post_id=post.idWHERE tag.tag='mysql'; 123SELECT * FROM tag WHERE tag='mysql';SELECT * FROM tag_post WHERE tag_id=1234;SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904); 三、存储引擎InnoDB是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 比较 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。 四、数据类型整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。 时间和日期MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。 1. DATETIME能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 2. TIMESTAMP和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 五、切分水平切分水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 垂直切分垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 Sharding 策略 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 Sharding 存在的问题1. 事务问题使用分布式事务来解决，比如 XA 接口。 2. 连接可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。 3. ID 唯一性 使用全局唯一 ID（GUID） 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法) 六、复制主从复制主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。 SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。 读写分离主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 参考资料 BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013. 姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011. 20+ 条 MySQL 性能优化的最佳经验 服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策 How to create unique row ID in sharded databases? SQL Azure Federation – Introduction MySQL 索引背后的数据结构及算法原理 MySQL 性能优化神器 Explain 使用分析 How Sharding Works 大众点评订单系统分库分表实践]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发]]></title>
    <url>%2F2018%2F12%2F04%2FJava%20%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[一、线程状态转换 新建（New） 可运行（Runnable） 阻塞（Blocking） 无限期等待（Waiting） 限期等待（Timed Waiting） 死亡（Terminated） 二、使用线程 实现 Runnable 接口 实现 Callable 接口 继承 Thread 类 实现接口 VS 继承 Thread 三、基础线程机制 Executor Daemon sleep() yield() 四、中断 InterruptedException interrupted() Executor 的中断操作 五、互斥同步 synchronized ReentrantLock 比较 使用选择 六、线程之间的协作 join() wait() notify() notifyAll() await() signal() signalAll() 七、J.U.C - AQS CountdownLatch CyclicBarrier Semaphore 八、J.U.C - 其它组件 FutureTask BlockingQueue ForkJoin 九、线程不安全示例 十、Java 内存模型 主内存与工作内存 内存间交互操作 内存模型三大特性 先行发生原则 十一、线程安全 不可变 互斥同步 非阻塞同步 无同步方案 十二、锁优化 自旋锁 锁消除 锁粗化 轻量级锁 偏向锁 十三、多线程开发良好的实践 参考资料 一、线程状态转换 新建（New）创建后尚未启动。 可运行（Runnable）可能正在运行，也可能正在等待 CPU 时间片。 包含了操作系统线程状态中的 Running 和 Ready。 阻塞（Blocking）等待获取一个排它锁，如果其线程释放了锁就会结束此状态。 无限期等待（Waiting）等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。 进入方法 退出方法 没有设置 Timeout 参数的 Object.wait() 方法 Object.notify() / Object.notifyAll() 没有设置 Timeout 参数的 Thread.join() 方法 被调用的线程执行完毕 LockSupport.park() 方法 - 限期等待（Timed Waiting）无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。 调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。 睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。 进入方法 退出方法 Thread.sleep() 方法 时间结束 设置了 Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll() 设置了 Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕 LockSupport.parkNanos() 方法 - LockSupport.parkUntil() 方法 - 死亡（Terminated）可以是线程结束任务之后自己结束，或者产生了异常而结束。 二、使用线程有三种使用线程的方法： 实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 实现 Runnable 接口需要实现 run() 方法。 通过 Thread 调用 start() 方法来启动线程。 12345public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125; 12345public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125; 1234567public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承 Thread 类同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 12345public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125; 1234public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 实现接口 VS 继承 Thread实现接口会更好一些，因为： Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口； 类可能只要求可执行就行，继承整个 Thread 类开销过大。 三、基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 主要有三种 Executor： CachedThreadPool：一个任务创建一个线程； FixedThreadPool：所有任务只能使用固定大小的线程； SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。 1234567public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable()); &#125; executorService.shutdown();&#125; Daemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 使用 setDaemon() 方法将一个线程设置为守护线程。 1234public static void main(String[] args) &#123; Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true);&#125; sleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 1234567public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; yield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 123public void run() &#123; Thread.yield();&#125; 四、中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。 InterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。 1234567891011121314public class InterruptExample &#123; private static class MyThread1 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println("Thread run"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new MyThread1(); thread1.start(); thread1.interrupt(); System.out.println("Main run");&#125; 123456Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at InterruptExample.lambda$main$0(InterruptExample.java:5) at InterruptExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) interrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 123456789101112public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123; // .. &#125; System.out.println("Thread end"); &#125; &#125;&#125; 12345public static void main(String[] args) throws InterruptedException &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125; 1Thread end Executor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。 12345678910111213public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; try &#123; Thread.sleep(2000); System.out.println("Thread run"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdownNow(); System.out.println("Main run");&#125; 12345678Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9) at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 1234Future&lt;?&gt; future = executorService.submit(() -&gt; &#123; // ..&#125;);future.cancel(true); 五、互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 synchronized1. 同步一个代码块 12345public void func() &#123; synchronized (this) &#123; // ... &#125;&#125; 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。 对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。 12345678910public class SynchronizedExample &#123; public void func1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125; 123456public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e1.func1());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 1234567public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e2.func1());&#125; 10 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 2. 同步一个方法 123public synchronized void func () &#123; // ...&#125; 它和同步代码块一样，作用于同一个对象。 3. 同步一个类 12345public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 12345678910public class SynchronizedExample &#123; public void func2() &#123; synchronized (SynchronizedExample.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125; 1234567public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func2()); executorService.execute(() -&gt; e2.func2());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 4. 同步一个静态方法 123public synchronized static void fun() &#123; // ...&#125; 作用于整个类。 ReentrantLockReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 123456789101112131415public class LockExample &#123; private Lock lock = new ReentrantLock(); public void func() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + " "); &#125; &#125; finally &#123; lock.unlock(); // 确保释放锁，从而避免发生死锁。 &#125; &#125;&#125; 123456public static void main(String[] args) &#123; LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; lockExample.func()); executorService.execute(() -&gt; lockExample.func());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 比较1. 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 2. 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 3. 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 4. 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 5. 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 六、线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 1234567891011121314151617181920212223242526272829303132333435public class JoinExample &#123; private class A extends Thread &#123; @Override public void run() &#123; System.out.println("A"); &#125; &#125; private class B extends Thread &#123; private A a; B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("B"); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; 1234public static void main(String[] args) &#123; JoinExample example = new JoinExample(); example.test();&#125; 12AB wait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 12345678910111213141516public class WaitNotifyExample &#123; public synchronized void before() &#123; System.out.println("before"); notifyAll(); &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("after"); &#125;&#125; 123456public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample example = new WaitNotifyExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 12beforeafter wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。 await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 123456789101112131415161718192021222324252627public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println("before"); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println("after"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 123456public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 12beforeafter 七、J.U.C - AQSjava.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。 CountdownLatch用来控制一个线程等待多个线程。 维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 1234567891011121314151617public class CountdownLatchExample &#123; public static void main(String[] args) throws InterruptedException &#123; final int totalThread = 10; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print("run.."); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); System.out.println("end"); executorService.shutdown(); &#125;&#125; 1run..run..run..run..run..run..run..run..run..run..end CyclicBarrier用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 1234567891011121314151617181920public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int totalThread = 10; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print("before.."); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.print("after.."); &#125;); &#125; executorService.shutdown(); &#125;&#125; 1before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after.. SemaphoreSemaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。 12345678910111213141516171819202122public class SemaphoreExample &#123; public static void main(String[] args) &#123; final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) &#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.print(semaphore.availablePermits() + " "); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125; 12 1 2 2 2 2 2 1 2 2 八、J.U.C - 其它组件FutureTask在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。 123456789101112131415161718192021222324252627282930public class FutureTaskExample &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int result = 0; for (int i = 0; i &lt; 100; i++) &#123; Thread.sleep(10); result += i; &#125; return result; &#125; &#125;); Thread computeThread = new Thread(futureTask); computeThread.start(); Thread otherThread = new Thread(() -&gt; &#123; System.out.println("other task is running..."); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); otherThread.start(); System.out.println(futureTask.get()); &#125;&#125; 12other task is running...4950 BlockingQueuejava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现： FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列 ：PriorityBlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。 使用 BlockingQueue 实现生产者消费者问题 1234567891011121314151617181920212223242526272829public class ProducerConsumer &#123; private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread &#123; @Override public void run() &#123; try &#123; queue.put("product"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print("produce.."); &#125; &#125; private static class Consumer extends Thread &#123; @Override public void run() &#123; try &#123; String product = queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print("consume.."); &#125; &#125;&#125; 1234567891011121314public static void main(String[] args) &#123; for (int i = 0; i &lt; 2; i++) &#123; Producer producer = new Producer(); producer.start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; Consumer consumer = new Consumer(); consumer.start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; Producer producer = new Producer(); producer.start(); &#125;&#125; 1produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. ForkJoin主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。 12345678910111213141516171819202122232425262728293031public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123; private final int threshold = 5; private int first; private int last; public ForkJoinExample(int first, int last) &#123; this.first = first; this.last = last; &#125; @Override protected Integer compute() &#123; int result = 0; if (last - first &lt;= threshold) &#123; // 任务足够小则直接计算 for (int i = first; i &lt;= last; i++) &#123; result += i; &#125; &#125; else &#123; // 拆分成小任务 int middle = first + (last - first) / 2; ForkJoinExample leftTask = new ForkJoinExample(first, middle); ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last); leftTask.fork(); rightTask.fork(); result = leftTask.join() + rightTask.join(); &#125; return result; &#125;&#125; 123456public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinExample example = new ForkJoinExample(1, 10000); ForkJoinPool forkJoinPool = new ForkJoinPool(); Future result = forkJoinPool.submit(example); System.out.println(result.get());&#125; ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。 1public class ForkJoinPool extends AbstractExecutorService ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。 九、线程不安全示例如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。 以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。 123456789101112public class ThreadUnsafeExample &#123; private int cnt = 0; public void add() &#123; cnt++; &#125; public int get() &#123; return cnt; &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; ThreadUnsafeExample example = new ThreadUnsafeExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 1997 十、Java 内存模型Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。 内存间交互操作Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。 read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock 内存模型三大特性1. 原子性Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。 为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。 下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。 AtomicInteger 能保证多个线程修改的原子性。 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现： 1234567891011public class AtomicExample &#123; private AtomicInteger cnt = new AtomicInteger(); public void add() &#123; cnt.incrementAndGet(); &#125; public int get() &#123; return cnt.get(); &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicExample example = new AtomicExample(); // 只修改这条语句 final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 11000 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。 1234567891011public class AtomicSynchronizedExample &#123; private int cnt = 0; public synchronized void add() &#123; cnt++; &#125; public synchronized int get() &#123; return cnt; &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicSynchronizedExample example = new AtomicSynchronizedExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 11000 2. 可见性可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 3. 有序性有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 先行发生原则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 1. 单一线程原则 Single Thread rule 在一个线程内，在程序前面的操作先行发生于后面的操作。 2. 管程锁定规则 Monitor Lock Rule 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 3. volatile 变量规则 Volatile Variable Rule 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 4. 线程启动规则 Thread Start Rule Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 5. 线程加入规则 Thread Join Rule Thread 对象的结束先行发生于 join() 方法返回。 6. 线程中断规则 Thread Interruption Rule 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 7. 对象终结规则 Finalizer Rule 一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 8. 传递性 Transitivity 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 十一、线程安全多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。 线程安全有以下几种实现方式： 不可变不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型： final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 1234567public class ImmutableExample &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put("a", 1); &#125;&#125; 123Exception in thread "main" java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9) Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 123public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125; 互斥同步synchronized 和 ReentrantLock。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 1. CAS随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 2. AtomicIntegerJ.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 12345private AtomicInteger cnt = new AtomicInteger();public void add() &#123; cnt.incrementAndGet();&#125; 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 3. ABA如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 1. 栈封闭多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 123456789public class StackClosedExample &#123; public void add100() &#123; int cnt = 0; for (int i = 0; i &lt; 100; i++) &#123; cnt++; &#125; System.out.println(cnt); &#125;&#125; 1234567public static void main(String[] args) &#123; StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();&#125; 12100100 2. 线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 123456789101112131415161718192021public class ThreadLocalExample &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); threadLocal.remove(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set(2); threadLocal.remove(); &#125;); thread1.start(); thread2.start(); &#125;&#125; 11 为了理解 ThreadLocal，先看以下代码： 12345678910111213141516public class ThreadLocalExample1 &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal1.set(1); threadLocal2.set(1); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal1.set(2); threadLocal2.set(2); &#125;); thread1.start(); thread2.start(); &#125;&#125; 它所对应的底层结构图为： 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; get() 方法类似。 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 3. 可重入代码（Reentrant Code）这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 十二、锁优化这里的锁优化主要是指 JVM 对 synchronized 的优化。 自旋锁互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。 对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁： 123public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3;&#125; String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作： 1234567public static String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。 轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。 下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。 轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。 当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。 如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。 偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。 当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。 十三、多线程开发良好的实践 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使用 BlockingQueue 实现生产者消费者问题。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 参考资料 BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007. 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. Threads and Locks 线程通信 Java 线程面试题 Top 50 BlockingQueue thread state java CSC 456 Spring 2012/ch7 MN Java - Understanding Happens-before relationship 6장 Thread Synchronization How is Java’s ThreadLocal implemented under the hood? Concurrent JAVA FORK JOIN EXAMPLE 聊聊并发（八）——Fork/Join 框架介绍 Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Java 并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础]]></title>
    <url>%2F2018%2F12%2F04%2FJava%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、数据类型 包装类型 缓存池 二、String 概览 不可变的好处 String, StringBuffer and StringBuilder String Pool new String(“abc”) 三、运算 参数传递 float 与 double 隐式类型转换 switch 四、继承 访问权限 抽象类与接口 super 重写与重载 五、Object 通用方法 概览 equals() hashCode() toString() clone() 六、关键字 final static 七、反射 八、异常 九、泛型 十、注解 十一、特性 Java 各版本的新特性 Java 与 C++ 的区别 JRE or JDK 参考资料 一、数据类型包装类型八个基本类型： boolean/1 byte/8 char/16 short/16 int/32 float/32 long/64 double/64 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 二、String概览String 被声明为 final，因此它不可被继承。 内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 不可变的好处1. 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 Program Creek : Why String is immutable in Java? String, StringBuffer and StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 StackOverflow : What is String interning? 深入解析 String#intern new String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 12345public class NewStringTest &#123; public static void main(String[] args) &#123; String s = new String("abc"); &#125;&#125; 使用 javap -verbose 进行反编译，得到以下内容： 123456789101112131415161718192021// ...Constant pool:// ... #2 = Class #18 // java/lang/String #3 = String #19 // abc// ... #18 = Utf8 java/lang/String #19 = Utf8 abc// ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V 9: astore_1// ... 在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。 以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 三、运算参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。 以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。 1234567891011121314151617181920public class Dog &#123; String name; Dog(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125; void setName(String name) &#123; this.name = name; &#125; String getObjectAddress() &#123; return super.toString(); &#125;&#125; 12345678910111213141516public class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog("A"); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A &#125; private static void func(Dog dog) &#123; System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog("B"); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B &#125;&#125; 如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。 1234567891011class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog("A"); func(dog); System.out.println(dog.getName()); // B &#125; private static void func(Dog dog) &#123; dog.setName("B"); &#125;&#125; StackOverflow: Is Java “pass-by-reference” or “pass-by-value”? float 与 doubleJava 不能隐式执行向下转型，因为这会使得精度降低。 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。 1// float f = 1.1; 1.1f 字面量才是 float 类型。 1float f = 1.1f; 隐式类型转换因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。 12short s1 = 1;// s1 = s1 + 1; 但是使用 += 或者 ++ 运算符可以执行隐式类型转换。 12s1 += 1;// s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型： 1s1 = (short) (s1 + 1); StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting? switch从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。 123456789// long x = 111;// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'// case 111:// System.out.println(111);// break;// case 222:// System.out.println(222);// break;// &#125; StackOverflow : Why can’t your switch statement data type be long, Java? 四、继承访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。 可以对类或类中的成员（字段以及方法）加上访问修饰符。 类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 123456789101112public class AccessExample &#123; private int id; public String getId() &#123; return id + ""; &#125; public void setId(String id) &#123; this.id = Integer.valueOf(id); &#125;&#125; 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 12345678910111213141516public class AccessWithInnerClassExample &#123; private class InnerClass &#123; int x; &#125; private InnerClass innerClass; public AccessWithInnerClassExample() &#123; innerClass = new InnerClass(); &#125; public int getValue() &#123; return innerClass.x; // 直接访问 &#125;&#125; 抽象类与接口1. 抽象类 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。 1234567891011public abstract class AbstractClassExample &#123; protected int x; private int y; public abstract void func1(); public void func2() &#123; System.out.println("func2"); &#125;&#125; 123456public class AbstractExtendClassExample extends AbstractClassExample &#123; @Override public void func1() &#123; System.out.println("func1"); &#125;&#125; 123// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiatedAbstractClassExample ac2 = new AbstractExtendClassExample();ac2.func1(); 2. 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112131415public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println("func2"); &#125; int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here&#125; 123456public class InterfaceImplementExample implements InterfaceExample &#123; @Override public void func1() &#123; System.out.println("func1"); &#125;&#125; 1234// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x); 3. 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 4. 使用选择 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 深入理解 abstract class 和 interface When to Use Abstract Class and Interface super 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 1234567891011121314public class SuperExample &#123; protected int x; protected int y; public SuperExample(int x, int y) &#123; this.x = x; this.y = y; &#125; public void func() &#123; System.out.println("SuperExample.func()"); &#125;&#125; 123456789101112131415public class SuperExtendExample extends SuperExample &#123; private int z; public SuperExtendExample(int x, int y, int z) &#123; super(x, y); this.z = z; &#125; @Override public void func() &#123; super.func(); System.out.println("SuperExtendExample.func()"); &#125;&#125; 12SuperExample e = new SuperExtendExample(1, 2, 3);e.func(); 12SuperExample.func()SuperExtendExample.func() Using the Keyword super 重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 五、Object 通用方法概览12345678910111213141516171819202122public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals()1. 等价关系 Ⅰ 自反性 1x.equals(x); // true Ⅱ 对称性 1x.equals(y) == y.equals(x); // true Ⅲ 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; Ⅳ 一致性 多次调用 equals() 方法结果不变 1x.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false 1x.equals(null); // false; 2. 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 123456789101112131415161718192021222324public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 12345678public class ToStringExample &#123; private int number; public ToStringExample(int number) &#123; this.number = number; &#125;&#125; 12ToStringExample example = new ToStringExample(123);System.out.println(example.toString()); 1ToStringExample@4554617c clone()1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 1234public class CloneExample &#123; private int a; private int b;&#125; 12CloneExample e1 = new CloneExample();// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' 重写 clone() 得到以下实现： 123456789public class CloneExample &#123; private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125; 123456CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 1java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 123456789101112131415161718192021222324public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125; 123456789ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 1234567891011121314151617181920212223242526272829public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125; 123456789DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 1234567891011121314151617181920212223242526public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125; 1234CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 六、关键字final1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2. 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 static1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块 静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println("123"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 1123 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = "静态变量"; 123static &#123; System.out.println("静态语句块");&#125; 1public String field = "实例变量"; 123&#123; System.out.println("普通语句块");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 七、反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 反射的优点： 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的API定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点： 尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 Trail: The Reflection API 深入解析 Java 反射（1）- 基础 八、异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种： 受检异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复； 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。 Java 入门之异常处理 Java 异常的面试问题及答案 -Part 1 九、泛型123456public class Box&lt;T&gt; &#123; // T stands for "Type" private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; Java 泛型详解 10 道 Java 泛型面试题 十、注解Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。 注解 Annotation 实现原理与自定义注解例子 十一、特性Java 各版本的新特性New highlights in Java SE 8 Lambda Expressions Pipelines and Streams Date and Time API Default Methods Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators Parallel operations PermGen Error Removed New highlights in Java SE 7 Strings in Switch Statement Type Inference for Generic Instance Creation Multiple Exception Handling Support for Dynamic Languages Try with Resources Java nio Package Binary Literals, Underscore in literals Diamond Syntax Difference between Java 1.8 and Java 1.7? Java 8 特性 Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。 What are the main differences between Java and C++? JRE or JDK JRE is the JVM program, Java application need to run on JRE. JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac” 参考资料 Eckel B. Java 编程思想[M]. 机械工业出版社, 2002. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 脑图大全]]></title>
    <url>%2F2018%2F09%2F27%2FJava-%E8%84%91%E5%9B%BE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前言这篇文章给出关于 Java 脑图总结 链接脑图大全]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java脑图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 后端常见面试问题总结大全]]></title>
    <url>%2F2018%2F09%2F27%2FJava-%E5%90%8E%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出一篇掘金上总结很好的一篇后端人员面试常见问题总结，我觉得非常棒！ 内容如下： 计算机网络常见面试题 Linux相关常见面试题 MySQL常见面试题 Redis Java 数据结构 算法 spring 链接Java 后端常见面试问题总结大全 下面再给出 Java集合 相关的链接 Java集合 总结 Set 集合 ConcurrentHashMap 基于 Jdk1.8 [源码解析] HashMap 总结 Map 集合、散列表、红黑树介绍 List 集合 TreeMap LinkedHashMap Collection 总览]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络常见面试题</tag>
        <tag>Linux相关常见面试题</tag>
        <tag>MySQL常见面试题</tag>
        <tag>Redis</tag>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>spring</tag>
        <tag>Map、List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库总结大全]]></title>
    <url>%2F2018%2F09%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出关于数据库MySQL的总结，很不错。 链接InnoDB记录存储结构InnoDB记录存储结构 InnoDB数据页结构InnoDB数据页结构 MySQL 命令执行过程和存储引擎概述MySQL 命令执行过程和存储引擎概述 MySQL 索引(上)MySQL索引(基础原理) MySQL 锁引(中)MySQL 锁引(索引优化) MySQL 的基本管理MySQL 的基本管理 MySQL 数据目录MySQL 数据目录 MySQL 概述MySQL 概述 MySQL 数据类型MySQL 数据类型 MySQL 表的基本操作(上)MySQL 表的基本操作(上) 数据库基本操作数据库基本操作(库的增删改查) 数据库表的基本操作(上)数据库表的基本操作(上) 数据库表的基本操作(下)数据库表的基本操作(下) 查询简介(一)查询简介(一) 查询简介(二)查询简介(二) 查询简介(三）表达式和函数查询简介(三）表达式和函数 查询简介(四) 类型转换和分组查询简介(四) 类型转换和分组 查询简介(五) 子查询查询简介(五) 子查询 查询简介(六) 连接查询查询简介(六) 连接查询 查询简介(七) 组合查询查询简介(七) 组合查询 数据的插入、删除、更新数据的插入、删除、更新 索引和锁终结版数据库两大神器[锁，索引] 数据库面试必看数据库面试必看]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL总结</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大基础排序总结]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%85%AB%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出八大基础排序的总结以及Java 实现。 链接八大基础排序总结]]></content>
      <categories>
        <category>算法数据结构</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 总结]]></title>
    <url>%2F2018%2F09%2F27%2FMyBatis-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言下面给出关于MyBatis 的总结。 链接MyBatis 入门 MyBatis [配置文件] MyBatis [关联映射] MyBatis [缓存、代理、逆向工程] MyBatis [与Spring 整合] MyBatis [面试题] 上面是关于MyBatis 的一些总结！ 仰望星空，脚踏实地！]]></content>
      <categories>
        <category>MyBatis总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试前需要了解的东西]]></title>
    <url>%2F2018%2F09%2F27%2F%E9%9D%A2%E8%AF%95%E5%89%8D%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出别人整理出的一些面试常见题目，在大二下面试的过程中经常问到的一些，这篇博文总结的也非常棒，里面也有博主自己整理的好的资源的链接。 仰望星空，脚踏实地！ 链接1.0 面试前需要了解的东西 2.0 几道让你拿offer的面试题 3.0 基础面试题 上面三个链接都包含的信息量比较大，需要耐心读完，理解！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>集合题总结</tag>
        <tag>Servlet+Tomcat题总结</tag>
        <tag>JSP题总结</tag>
        <tag>JDBC题总结</tag>
        <tag>数据库题总结</tag>
        <tag>HTTP题总结</tag>
        <tag>XML+JSON题总结</tag>
        <tag>过滤器监听器</tag>
        <tag>AJAX题总结</tag>
        <tag>MyBatis题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说几道简单算法题]]></title>
    <url>%2F2018%2F09%2F27%2F%E8%AF%B4%E5%87%A0%E9%81%93%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简答算法总结先给出八大排序的链接： 八大基础排序总结 链接 上面的理解后，下面给出常见简单算法题： 十道简单算法题(一) 十道简单算法题(二)]]></content>
      <categories>
        <category>算法数据结构</category>
      </categories>
      <tags>
        <tag>简单算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统总结]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言下面给出操作系统相关的总结 操作系统第一篇 [引论] 操作系统第二篇 [进程管理] 操作系统第三篇 [线程] 操作系统第四篇 [处理机调度] 操作系统第五篇 [死锁] 操作系统第六篇 [存储器管理] 操作系统第七篇 [设备管理] 以上便是关于操作系统的一些总结好的文章。我会在后面的学习中，自己再学习，之后再进行补充，形成自己的理解。 脚踏实地，仰望星空！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 总结]]></title>
    <url>%2F2018%2F09%2F27%2FSpring-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言本篇博客是关于框架Spring 的一些好的总结，给出链接以更好的学习。 链接Spring 入门第一篇 Spring [依赖注入] Spring [AOP模块] Spring [DAO模块] SpringMVC [开发Controller] SpringMVC [参数绑定、数据回显、文件上传] SpringMVC [校验器、统一处理异常、RESTful、拦截器] SpringBoot 入门 SpringData JPA 入门 Spring IOC 总结 Spring AOP总结 上面是关于Spring 的一些总结，非常棒。 脚踏实地，仰望星空！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令]]></title>
    <url>%2F2018%2F09%2F25%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81-Linux-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常见Linux命令目录切换命令 cd usr ：切换到usr目录下 cd..或者cd../：回退到上一级目录 cd /：切换到系统根目录下 cd ~：切换到用户主目录 cd -：切换到上一个所在目录 目录的操作命令（增删改查） mkdir 目录名称：增加目录 ls或者ll（ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息 find 目录 参数： 寻找目录（查） mv 目录名称 目录的新位置： 移动目录的位置—剪切（改） cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r代表递归拷贝 rm [-rf] 目录: 删除目录（删） 文件的操作命令（增删改查） touch 文件名称: 文件的创建（增） cat/more/less/tail 文件名称 :文件的查看（查） 123456789- cat：只能显示最后一屏内容- more：可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看- less:可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看- tail-10 ：查看文件的后10行，Ctrl+C结束注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 vim 文件： 修改文件的内容（改） vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤： 1vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。） rm -rf 文件： 删除文件（删） 同目录删除：熟记 rm -rf 文件 即可 压缩文件的操作命令（１）、Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件 其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令： 1tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf test.tar.gz /test/ （２）、解压压缩包： 命令：tar [-xvf] 压缩文件 其中：x：代表解压 示例： 1231 将/test下的test.tar.gz解压到当前目录下可以使用命令：tar -xvf test.tar.gz2 将/test下的test.tar.gz解压到根目录/usr下: tar -xvf xxx.tar.gz -C /usr（- C代表指定解压的位置） 其他常用命令 pwd： 显示当前所在位置 grep 要搜索的字符串 要搜索的文件 –color： 搜索命令，–color代表高亮显示 ps -ef/ps aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程） 注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。 kill -9 进程的pid： 杀死进程（-9 表示强制终止。） 先用ps查找进程，然后用kill杀掉 网络通信命令 查看当前系统的网卡信息：ifconfig 查看与某台机器的连接情况：ping 查看当前系统的端口使用：netstat -an shutdown： shutdown -h now： 指定现在立即关机；shutdown +5 &quot;System will shutdown after 5 minutes&quot;:指定5分钟后关机，同时送出警告信息给登入 reboot： reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）。 Linux命令链接下面给出常见Linux 命令网址大全 Linux命令大全]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入 URL 到页面加载发生了什么]]></title>
    <url>%2F2018%2F09%2F25%2F%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言从输入 URL 到页面加载发生了什么？面试过程中也问过，下面一篇是很不错的文章。 大致总结： DNS 解析 TCP三次握手建立连接 发送HTTP请求 服务器处理请求并返回响应报文 浏览器进行解析渲染 TCP四次挥手连接结束 链接从输入 URL 到页面加载发生了什么]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络常见面试题</tag>
        <tag>HTTP</tag>
        <tag>TCP/UDP</tag>
        <tag>三次握手/四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String StringBuffer StringBuilder 有什么区别]]></title>
    <url>%2F2018%2F09%2F24%2FString-StringBuffer-StringBuilder-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int 和 Integer 有什么区别]]></title>
    <url>%2F2018%2F09%2F23%2Fint-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java 虽然号称是面向对象的语言，但是原始数据类型仍然是重要的组成元素，所以在面试中，经常考察原始数据类型和包装等Java 语言特性。 今天一起看看： int 和Integer 有什么区别？谈谈Integer 的值的缓存范围。 典型回答 int int 是我们常说的整形数字，是Java 的8个原始数据类型（boolean、byte、short、char、int、float、double、long）之一。Java 语言虽然号称一切都是对象，但是原始数据类型是例外。 Integer Integer 是int 对应的包装类，它有一个int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间的转换等。在Java5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。 Integer 缓存 关于Integer缓存，这设计到Java5 中另一个改进。构建Integer 对象的传统方式是直接调用构造器，直接new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范范围，因而，在Java5 中新增了静态工厂方法valueOf ，在调用它的时候会利用一个缓存机制，带来明显的性能改进。按照Javadoc 这个值默认缓存是[-128,127]之间。 考点分析今天的问题涵盖了Java 里两个基础要素：原始数据类型、包装类。谈到这里，就可以非常自然的拓展到自动装箱、自动拆箱机制，进而考察封装类的一些设计和实践。坦白说，理解基本原理和用法已经足够日常工作需求了，但是要落实到具体场景，还是有很多问题需要仔细思考才能确定的。 比如： Java 使用的不同阶段，编译阶段、运行时，自动装箱/自动拆箱是发生在什么阶段？ 静态工厂方法valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗? 为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？ 阅读过Integer 源码吗？分析一下类或者某些方法的设计要点。 知识拓展理解自动装箱、拆箱自动装箱实际上算是一种语法糖。 什么是语法糖？可以简单理解为Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它发生在编译阶段，也就是生成的字节码是一致的。 像前面提到的整数，javac 替我们自动把装箱转换为 Integer.valueOf() ,把拆箱替换为Integer.intValue() ，这似乎也顺序回答了另一个问题，既然调用的是Integer.valueOf ,自然能够得到缓存的好处了。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对比 Hashtable HashMap TreeMap 有什么不同]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%AF%B9%E6%AF%94-Hashtable-HashMap-TreeMap-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 fianl finally finalize 有什么不同]]></title>
    <url>%2F2018%2F09%2F21%2F20180921-%E8%B0%88%E8%B0%88-fianl-finally-finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[1所谓博客，不过孤芳自赏 一道 Java经典的基础题目： 谈谈 fianl finally finalize 有什么不同 典型回答 final： final 可以用来修饰类、方法、变量，分别有不同的意思。 （1）、修饰类：修饰的class代表不可以继承拓展 （2）、修饰方法：修饰的方法不可以重写（override） （3）、修饰变量：修饰的变量是不可以被修改的 finally finally 是java 用来保证重点代码一定要被被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。 finalize finalize 是基础类 java.lang.Object 的一个方法，他的设计目的是保证对象在被垃圾收集前完成资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。 考点分析这是一道非常经典的 Java 基础问题，上面的回答主要是从语法和实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察我们对性能、并发、对象生命周期或垃圾收集基本过程的方面的理解。 final推荐使用 final 关键词来明确表示我们代码的语义、逻辑意图，这已经证明在许多场景下是非常好的实践，比如： 我们可以选择将方法或者类声明为 final,这样就可以明确告诉别人，这些行为是不允许修改的。 在 Java 许多的类库中定义的源码，在 java.lang 包下的很多类，相当一部分都被声明为 final class ? 在第三方类库的一些基础类中同样如此，这样可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。 使用 final 修饰参数或者变量，也可以很清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有的方法参数、本地变量、成员变量声明为 final 。 final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用与保护只读数据 ，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的需要。 final 也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景中提高性能，比如，利用final 有助于JVM 将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能JVM （如HotSpot）判断内联未必依赖final 的提示，要相信JVM 还是非常智能的。类似的，final 字段对性能的硬影响，大部分情况下，并没有考虑的必要。 finally对于finally ，明确的知道怎么使用就足够。需要关闭的连接等资源，更推荐使用 Java7 中添加的 try-catch-resource语句，因为通常Java 能够很好的处理异常情况，编码量也要少很多。何乐而不为？ 另外我们要注意一些常被考到的 finally 问题（也比较偏门），至少需要了解以下。比如，下面的代码会输出什么？ 123456try&#123; //do something System.exit(1);&#125;finally&#123; System.out.println("Print from finally");&#125; 上面的finally 里面的代码可不会被执行哦，这是一个特例。 finalize对于finallize ，我们要明确它是不推荐使用的，业界实践一再证明他不是个好的办法，在Java 9 中，甚至明确将Object.finalize() 标记为 deprecated ！如果没有特别的原因，不要实现finalize() 方法，也不要指望利用它来进行资源回收。 为什么呢？简单说，你无法保证finalize() 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。 通常来说，利用上面的提到的try-with-resource 或者try-finally 机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑Java 提供的Cleaner 机制或者其他的替代方法。接下来，我们介绍更多的设计考虑和实现细节。 知识拓展关于final注意：final 不是immutable! 前面介绍了final在实践中的好处，需要注意的是，final 并不等于immutable ，比如下面这段代码： 123456final List&lt;String&gt; strList = new ArrayList();strList.add("1");strList.add("2");strList.add("3");List&lt;String&gt; unmodifiableList = List.of("1","2");unmodifiableList.add("3"); //运行时会报错 final 只能约束strList 这个引用不可以被赋值，但是strList 对象行为不被 final 影响，添加元素等操作完全是正常的。如果我们真的希望对象本身是不变的，那么需要相应的类支持不可变的行为，在上面的例子中，List.of() 方法创建的本身就是不可变的List ，最后这句add（） 是会在运行期间抛出异常的。在Java9中Lis新特性中List.of() 源码： 123static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);&#125; ImmutableCollections 的源码： 1234567ListN(E... input)&#123; E[] tmp = (E[])new Object[input.length]; for(int i =0;i&lt;input.length;i++)&#123; tmp[i] = Object.requireNonNull(input[i]); &#125; this.elements=tmp ;&#125; 在new Object(input.length) 中，已经将添加的长度定死了。 immutable 在很多场景中是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，如果要实现immutable 的类，我们需要做到： 将class自身声明为final ，这样别人就不能拓展绕过限制了。 将所有成员变量定义为private 和final ，并且不要实现setter 方法。 通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。 如果确实需要实现getter 方法，或者其他可能返回内部状态的方法，使用copy-on-write 原则，创建私有的copy 。 这些原则在并发编程实践中也经常被用到。关于setter 和getter 方法，很多人喜欢直接用IDE 一次全部生成，建议最好是需要时有需要时再实现。 关于finalizefinalize 真的那么不堪？ 前面简单介绍了finalize 是一种已经被业界证明了不好的实践，那么为什么会导致那些问题呢？ finalize 的执行是和垃圾收集关联在一起的，一旦实现了非空的finalize 方法，就会导致相应对象回收呈数量级上的变慢，有人专门做过benchmark ，大概是40~50倍的下降。 因为finalize 被设计成在对象收集前调用，这就意外着实现fianlize方法的对象是个“特殊公民”。JVM 要对它进行额外的处理。finalize 本质上成为快速回收的阻碍者，可能导致你的对象经过垃圾收集周期才会被回收。 实践中，因为finalize 拖慢垃圾收集，导致大量的对象堆积，也是一种导致OOM 的原因。 从另外一个角度，我们要确保回收资源就是因为资源是有限的，垃圾收集时间的不可预测，可能会极大的家具资源占用。这意外着对于消耗非常高频的资源，千万别指望着finalize 作为最后的“守门员”，况且他已经暴露了如此多的问题。所以，用完资源推荐显示释放，或者利用资源池尽量重用。 总结今天，我们从语法角度分析了final 、finally 、finalize ，并且从安全、性能、垃圾收集等方面逐步深入，探讨实践中的注意事项。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这里，三家寨的风土人情]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%85%B3%E4%BA%8E%E8%BF%99%E9%87%8C%EF%BC%8C%E4%B8%89%E5%AE%B6%E5%AF%A8%E7%9A%84%E9%A3%8E%E5%9C%9F%E4%BA%BA%E6%83%85%2F</url>
    <content type="text"><![CDATA[或许满怀着期待和憧憬，所以抵挡住了一天一夜的车程的疲惫。在昭通火车站下火车后，我们就被接着走了。因夜已深，大部分餐馆已经闭门歇业，只有拐角处的一家烧烤店在打扫着最后关门前的烧烤屋，阿訇和寺管叔叔请我们在此吃了一顿烧烤。随后我们四人便向目的地前进，送走了另外两位后，又载着我们来到了三家寨。或许是因为放下了高度紧绷的神经，坐上车便已睡意朦胧。 靠在搭档的肩膀上睡着了，不知不觉便已到了，让我们惊讶的是我们见到的住宿环境比我们想象的要好的多的多，床铺子都是新的，软软的很舒服。住宿是在教室里，教室里有11张桌子，其中一张是讲桌，能坐下40人左右。送走了阿訇，伴随着疲惫，我也很快进入了梦想。 晨礼下来后，又睡着了。起来已经是七点半了，问了一下阿訇，让我们上午先休息休息，下午再去家访进行招生。坐不住的我们，在奥雪和紫优还有其他小朋友的带领下出去在村子里转了转。 说起是村子，却也没住着几户人家。这里地形是靠山，村子的形成是在两座大山的缝隙里蜿蜒形成的，有一条硬化路，随着地形在不远的尽头也看不到头了。我们先是沿着路走了离寺不远的几十米，身边的小朋友告诉我，我们不能再往下走了，我问为什么，小朋友告诉我，再往下走就是汉族的村庄了。寺管大哥家是沿路最后一家，和不远处的汉族村子相距40几米的样子。遇到了寺管大哥，叫我们进去坐一坐，想着不给人家找麻烦了，就在路口我们聊了聊，寺管大哥告诉我，这里主要农作物就是土豆和玉米。田地也不是很多，全部在山坡上，“支离破碎”。每家的年轻劳动力基本都是出去外面打工了，只留下几间略显荒凉又有点破旧的房屋坐立在山坡上。 大哥在教门上是一个很有上进心和思想的人。以前这里的人们近乎达到了野蛮的状态，我当时并不明白这个野蛮是一种什么样的野蛮，后面大哥告诉我，以前村子里的人经常去隔壁村子闹事，那里的汉族都怀有了一种敌意和敬畏之心。但是后来改变了，那个村子里的人们开始说，你们村子里的那些人为什么这些年不见了。叔叔告诉我，这是因为真理来到了这个地方，自从1998年建立了这座清真寺后，这里的人们就开始慢慢改变了，他们知道了人生存在的意义，就是要劝人行善，止人作恶…。感赞，这里的人们得到了主的引领。 聊了一会儿我们便开始回去了，在回去的路上，看到了一位大叔在修双轮拉灰车，我过去说了一句赛俩目，他并没有给我回复，只是看着我笑了笑。屋子里出来了马关丹的妈妈，刚才那位是马关丹的爸爸。马关丹是一位脚上有残疾的女孩子，一直不说话，只是跟着我们一起在后面走着，后来阿訇家的女儿告诉我，她的脚是因为小时候上台阶的时候摔了，她妈妈没有给她看病，所以成了现在的样子，当时的我心里还在想这位妈妈好狠心呀。后来她妈妈从屋子里出来时，我说了一句赛俩目，她妈妈也回复了我。在交谈中，还是有语言障碍的，说的基本听不懂，只有根据话里的一些词去判断她说的是哪方面的内容。她们家的房子很破很破，因为这几天下雨的缘故，我都感觉快塌了。屋外也没有什么大面积的院子，只有一条从硬化路到家门口的一个小路，和家门口到山脚下牛棚里的一条路，有2头牛，还有一些鸡。聊着聊着，我才知道这个家庭的命运也多苦了，我无法得知她说的全部内容，但是她说着说着便开始哽咽，眼睛中有泪花在打转。她告诉我她有时候都不想再活着这个世上了，不知道还有什么要活得，我知道这个家庭很不幸，她已经承受了很多很多。 生了2个儿子，全部夭折了，一个女儿腿脚上还留下了残疾，丈夫他也给我说了，但是没有听懂，但是可以判定家长的劳动力几乎是他一个人。种着几亩田地，一年下来也才能收获2000元上下。只够养活这个家，她告诉我自己47岁了，但我从她的脸上却看到了60几岁老人的模样，俨然不像她说的那个年龄，但是女儿却也只有10岁。最后她说，感赞，我们都还活着。马关丹戴着头巾，一直默默的跟在我们的身后。 我听着内心很沉重，回到了寺里，师娘叫着吃饭呢。 下午做完pieshi，我们就在阿訇家子女的带领下去家访，其实也没有走几家，大多数家中都是老人，或者门早已紧闭，荒草丛生。 不一会儿我们便又采访回到了原点，师娘又叫我们吃饭。早晨都是沿着路超着山下坡方向去看了看，下午沿着山坡向上走去采访，这里的房屋大多数都是两种建筑，一种是土墙房子，没有窗口那种，感觉和窑洞一样，一种是二层平顶瓦房，之所以是二层平顶瓦房，我想是因为地理原因，这里平地面积少之又少，靠天吃饭，平顶可以把上面的水全部收集。 我们的旁边只有一家商店，标准的来讲，是小买铺，是陈奥雪家开的，下午她才告诉我，她们家也即将要搬走了，在城里已经租好了房子，她妈妈在城里可以买杂货，她在城里上学。之所以她告诉我这个消息，是因为我想买一些作业本和画画本，想让孩子们尝试每天写日记，问了一下奥雪说她们家也没有什么本子了。这里没有进城的公交，有的只是绵延的那条仅有的硬化路，和路旁边的马粪和牛粪，因为在半山腰耕地要用到牛和马。想刷个牙，却只拿了牙膏，想买都没有个去处，只好洗小净时多洗洗牙。 总有一些人，连我们习以为常的东西都是一种奢侈，不论什么。但是他们却各个善良热情，虽然也有生活的疲惫，但从内心里，爱也是人的一种天性。明天要开课了，不知道能来多少个像奥雪紫优这样懂事又可爱的孩子，但我们希望他们都能来。 原文链接]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>支教</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试后想对你说]]></title>
    <url>%2F2018%2F05%2F13%2F%E9%9D%A2%E8%AF%95%E5%90%8E%E6%83%B3%E5%AF%B9%E4%BD%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[前序开始时，抱着一颗暑期找实习的心态开始在实习僧和拉勾网上疯狂的投简历，投了很多很多。起初，会因为自己的简历状态是投递成功或者已被查看而欣喜不已。之后，就是一边心里乱激动一边又焦急的等待面试的邀请。效率最高的当为今日头条的效率，投了一天就打来电话确定面试时间和方式。其他的后面好像就石沉大海了，在拉勾网和实习僧上大多数简历状态最终的归宿就是以时间不合适或者经验不合适的标签落入了人家的人才库。不知道各个公司的人才库里装了多少像我这样的人。有些事情总有一个第一次，我的第一次面试就是今日头条，是视频面试，面试前的那一点点小小的紧张很微妙。后面，随着时间的推移，那些紧张也不翼而飞了，但是依旧会因为看到简历筛选和打来面试预约电话而内心小激动，想象一下，一头可爱的小鹿在心间直撞，停不下来的~那种心动的感觉。 后面的时候，依旧投了很多简历，后续收到了阿里、百度、携程等大小公司的或电话面，或视频面，或现场面的邀请。或许面试的形式也就无非这三种吧，没错，我都经历过了。有的一面，有的走到了二面，很不幸，没有走到三面的。要是能走到三面，实习offer也就基本到手了吧。 在找实习的这段时间里，也有非常大的收获，除了面试不会再紧张，还有很多面试时的提问，知识点的考察等的掌握。以前看书时，看了很多遍，但依旧可能不会在脑海中刻下。但是经历过第一次面试之后，一面会考什么，一个大体的范围就确定了，再在牛客网上多看看那些帖子和面经，就会发现，大部分公司的一面无非也就是那些东西了，所以下来后再看那些知识点的确理解的更透彻了，也掌握了，实践是检验真理的唯一标准。每一次的面试完后都会把面试完的知识点写下来，刚开始的时候，会发现，面试电话刚挂后，刚才面试了个啥，已经忘了，好快哟。后面就长经验了，要是电话面试，接电话的前一秒就是把录音开启，然后再就让他面吧，不要虚。下来之后，还可以听听自己的声音（嗯~声音也蛮好听的hhh），问题回答的怎么样，都可以事后慢慢总结这场面试过程回答问题的思路和一些表达方式上的不足。再总结，下次电话面试就会注意这些点了。一步一步，你会发现你在面试上的成长。因为在经历了华为的现场面时，我体会到了自己的成长。关于华为这儿，我后面再说，这开启了我倒霉又有收获的一天。 关于面试关于面试，在技术上，一面会考察很基础的知识，我起初时以为自己掌握了那些知识，但是头条面试完后，发现自己那是一种自我陶醉。陶醉在自己的世界里，有些知识就是停留在知道他是干什么的层面上。这时候，就会激发你知其然和知其所以然的渴望了，我要把他弄懂！ 一面后发现自己：哇，好菜呀~真的太菜了！没错，我的自信心被打击到了。所以，一边自我悲伤，一边快速逃离悲伤，还要一边继续把他搞定！这样的打击后，才会沉下心去。其实，生活中要得有那么点的打击，这样才能让自己认识到自己还活着，还有情绪的喜怒哀乐。关于打击，我想我受的足够多了，我身边的大佬太多了，也太强了！鲁迅先生说，世界上本没有路，走的人多了，也就有了路。打击也是一样：第一次打击的时候，你很悲伤，打击的多了，也就习以为常了！慢慢的，也就不去理会打击的感觉了，唯有好好学习去弥补就是了。 其他的面试我也总结过，这儿就不说了。这儿想说一下昨天的华为现场面试： 华为西安研究所 华为的现场总共两次，一面和二面都在一起，要是二面过了，好像就可以拿到口头实习offer了。在等待被叫面试的时间段里，发现自己身边的人大多数是大三的和研究生的，很多人一面几分钟就结束了，也有很多人被面试了好长时间。我就是那个被面试了好长时间的人。 他看了看我的简历，首先肯定是自我介绍了，我自己介绍了一下自己，说自己现在大二。他也很惊讶，大二就出来了。简历上写的东西为啥别人的都会问到会的，我就被问到项目了。我心里想，叔，你就问我点基础呗，我给你说一说。项目我才开始做，就知道怎么用呀，你能让我给你说啥！好巧的是，他就不问基础，问我框架方面的原理，还有很多…。具体的我就不说了，但是到最后，他就給我说大学生活和工作经验，告诉我，大学里是试错成本最低的时候，也是青春里最好的时光。有些错，当走上社会的时候，成本太高了，他说，欠下的东西，终究是要还的…告诉我不要太着急。聊了很久，给了我一些建议…。 感受之后，我也采纳了他的建议，走出门后，感觉一下子心情舒畅了很多。找实习先告一段落了。再说了，自己内心中真正呼唤自己的并不是把大学里为数不多的暑假在大二结束先祭奠了社会。内心中真正想要的是自己不一样的大学生活和经历，是日后可以回忆起来即感动又温馨的记忆，比如去支教一次等等。 实习的时间等到大三再祭奠社会吧。那时，我或许会成长的刚刚好，而我心怡的公司也刚好发现了我。这种东西就像有些人口中拿感情说事的话：感情这东西，谁说的上，或许上一秒擦肩而过，下一秒就一见钟情了呢。我想：未来这东西，定不会辜负你的努力的，或许上一次我还需沉淀，或许下一次，我就可以实现自己。唯有时间会告诉我答案~！ 所以，世界上没有白读的书，每一本都算数。也没有白走的经历，每一次都有收获。大二的我经历了这些面试后，虽然没有拿到最初抱着试试心态的实习offer。但是这些面试经历和面试官的交谈给了我自己知道的很多东西。 路，得自己选择，也得自己走。怎么走，也只有自己能决定，回顾至今大学的生活，我觉得自己确实被引导着，每一个寒假和暑假都过的很难忘和幸福，每一段在校时间也过的很丰富，但难免会有不一样的一段经历使你跌入低谷，但也会发现是那段低谷成就了现在坚强的你。遇到了很多有趣优秀的人，也做了一些记忆深刻对现在的我有这深深影响的事儿，（知感）。所以，别人的优秀你只能拿来做榜样，但不能效仿走一样的路。那样会发现自己过的很累很累。 毕业季14级毕业欢送会 所以，值此毕业季，我告诉自己：他们的今天的离开也就是你明天的离开，但幸运的是我还有时间，还有机会可以选择自己的路，可以做自己的喜欢做的事儿，可以亲自绘画属于自己的不一样的人生蓝图和明天。 最后应该告诫自己，也该告诫我的小伙伴们： “以时光盟誓，一切人确是在亏折之中。唯信道而且行善，并以真理相劝，以坚忍相勉的人则不然。” 坚忍行善 只愿这些即将毕业的学长学姐们，愿你们走遍天涯归来仍少年。也愿不管遇到什么困难，相信allah与我们同在！更希望年轻的我们抓住时间，别做语言上的巨人，行动上的矮子。 关于母亲节做杜瓦 或许你我都是这个世界中最平凡的人，但是我们都拥有世界上最不平凡的父爱和母爱。不论走到哪里，父母的心或许总是都在我们子女的身上。所以，不要仅仅是在母亲节或者父亲节上的某一天去表达我们的爱，而是常常的给他们多打几个电话，报一声健康和平安。在我们没有经济能力去报答的时候，请将我们的祝福放在我们的堵哇伊里。有经济能力的时候，更要如此！ 结尾本想着，写一写昨天自己的遇到的事儿，谁想，写着写着写到这里来了，说了这些。可以看到我的标签是要写自己自行车被别人骑走了，我和学长体验《唐人街探案》的激动人心的时刻，还有自己昨天坐车坐过站点很多站的荒凉。自行车丢的前一天，我的书在C楼也不见了，想表达一下自己对那些不自觉人的强烈不满。感觉自己花费时间去查监控，到头来自行车还找到了，也那么解决了，那我的那些精神损失需不需要费用呀？！！！ 但是，话又说回来，我俩个借此机会体验了一把什么叫做：校园无死角的视觉既视感！！！（校园里真的无死角） 所以，我把大冰《我不》书里的一句话写到这里，以此勉励： “星光不问赶路人，时光不负有心人。”也愿即将离去和后面将要离去的校园人阳光下活的像个小孩，风雨里像个大人。 你好，明天 你好，明天 你好，明天！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记百度 Java 实习第二面]]></title>
    <url>%2F2018%2F04%2F18%2F%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言突如其来哦，毫无防备…… 面试内容1、HashMap的存储结构 2、HashMap扩容过程旧数据如何处理？位置还是原来位置吗？ 3、HashMap对key有什么要求吗？一般用String作为key，问我能否用int或者其他Object类型 4、Object作为HashMap的key的话，对Object有什么要求吗？ 5、Object若不重写hashCode()的话，hashCode()如何计算出来的？ 6、hashCode()和equals()方法有什么联系？ 7、若对一个类不重写，它的equals()方法是如何比较的？（==比较） 8、==比较的是什么？ 9、hashCode()和equals()方法有什么要求吗？ 10、简单算法题：将一个二维数组顺时针旋转90度，说一下思路。 11、简单算法题：将一个int类型数字、负数逆序输出，须返回一个int类型数字。即反转 12、String能继承吗？就说到了用final修饰 13、final怎么用？分别说了修饰变量、方法、类 14、ConcurrentHashMap的分段锁原理 15、Java中有几种方式启动一个线程？（说了个start()、线程池不知道对否） 16、线程池有什么好处？ 17、Java中有几种线程池？ 18、TCP的三次握手 19、TCP如何保证可靠传输？ 20、框架用过哪些？说刚入门Spring、经典三层MVC 21、项目 22、Servlet是线程安全的吗？不安全 后记完了就说，嗯好了解了，那我们今天先到这里。加油]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记百度 Java 实习第一面]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言几天前，百度方面就打来了电话，和我确定了面试时间，没错，就是今天下午二点。我一点半就午休起来等待电话铃声的响起，过了两点后，还没有来，我的内心更慌了，过了十分后铃声突然响起，响了几秒钟就接了，哈哈。 面试内容这次把面试的主要内容简单介一下，有些问题回答的不太好，需要再仔细琢磨，主要内容如下： 1、简单自我介绍，（西电大二，自学Java，想找实习，balabala）….. 2、简要介绍简历上项目：网上图书商城，主要功能有哪些？用到哪些技术栈？说到了经典MVC三层框架，简单介绍 3、看我正在学习Spring，让简要说一下spring Ioc 4、问我是否用过spring+springMVC？ 5、有没有学过数据结构——&gt;引出数组和链表的区别？说到了数组和链表增删速度以及为什么？ 6、给了我10亿条散乱、无序的数据，让我找出1000个最大的数，问我有什么想法吗？（傻傻的说到了排序，递归，面试官自言到：用递归吗？凉了。。。一看我胡说，就再没有问） 7、Java 递归栈最深能递归多少次（说10个数据的话，递归肯定会溢出。这个我，没说上） 8、排序（和10亿数据有关，没回答上，让我下去了解一下） 9、JVM内存区域、类加载过程 10、类卸载发生到什么时候？ 11、JVM 垃圾对象回收相关（引用计数法、可达性分析算法判断对象死活；常用垃圾回收算法G1(JDK1.7以上)） 12、垃圾回收算法（标记清除，标记整理，复制算法） 13、什么时候会触发新生代、老年代垃圾回收？ 14、Java 内存模型 15、锁机制：volatile（内存可见性、禁止指令重排序），sychronized（monitorenter和monitorexit）在内存方面进行解释。同一时间，两个线程访问一个被sychronized修饰的方法块，JVM是如何阻止另外一个线程访问的？（面试官说回答的差不多） 16、数据库索引，索引如何做到快速查询？（不了解） 17、HTTP协议：问到后端给前端传递一条数据，HTTP是如何进行传递的？消息体里有哪些？后端传递的数据放在了HTTP哪里？（消息体这儿答得不太好，即数据内容怎么存放的？） 18、问我大一时参加的星火杯是什么？ 19、问我有没有什么展示我代码功底的：说到了Github 20、面试官问我有什么要问她的？（对，面试官是小姐姐诶），问了部门业务——大数据，部门人数—1000到2000 21、问我什么时候能去实习？ 后记然后就完了，对，完了。面试官说今天就聊这儿吧。所以还会有明天吗？挂了之后就想起来怎么没有问会有面试结果通知吗，嘎嘎嘎嘎嘎嘎。。。 总体感觉回答的还可以，也有答得不好的地方，要去努力了！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记阿里巴巴 Java 实习第一面]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%B0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言炎热的下午，刚在体育课上测完了一千米，嗓子要着火了，跑完后感觉要膨胀了，又测了50、身高、肺活量、体前屈。测完后就在树荫下休息，离下课还有10分钟的时候，口袋里的手机突然想起，拿起一看，阿里巴巴集团，当时就意识到可能是要和我商量面试时间，但接了后，却和其他公司不一样，面试官直接就问我，有时间吗？我们简单面试一下。我看了看体育老师，过去请了个假，就赶紧去一边面试了，不知道为什么声音很小，我有点儿听不清，好几次就请求面试官：“不好意思呢，刚才没听清，嘻嘻~”挺尴尬的。面试了34分钟。我到现在有的问题都忘了，大体内容如下： 面试内容1、自我介绍：balabala 2、现在都学习了些什么？balabala 3、HashMap底层实现原理，是否读过HashMap源码？ 4、HashMap和ConcurrentHashMap在线程安全上有何区别？如何实现？ 5、项目：小程序。问到遇到什么问题吗？在这里问了好多，还有业务逻辑，感觉答得都不是太好。 6、了解过哪些中间件？ 7、Java 的特性？ 8、Java 内存模型 9、JVM 类加载机制 10、双亲委派模型 11、Object都有哪些方法？ 12、高并发、高并发、高并发！重要的说三遍。如何解决？答得不太好，一脸懵逼！ 13、锁优化CAS 14、sychronized和volitile 15、反射的使用场景？很重要，我没怎么说上来。下来后回想感觉应该和框架（Spring）还有关系,以后学习得注意点。 16、还问了我的英语怎么样？考六级了吗 17、在Github上关注了什么开源项目了没？ 18、看了我的博客（挺开心的，感觉博客搭建上还是挺好的），问我是自学吗？一般怎么学？ 19、了解Linux吗？确实没咋用，就说了知道几个命令。 20、觉得自己是一个怎样的人？ 21、又想起来了，还问到了异常？并解释为什么？ 大概就这些吧，有些记不起来了，最后也没像头条面试官一样，问我有什么问题要问吗？就说那就今天先面试到这儿，我说了声谢谢。哦，对了，开头自我介绍前，还问我什么时候可以来实习，能实习多长时间？然后就没了，大厂面试就这样结束了。不知道结果会怎么样，以我现在的知识，估计也去不了，还得继续加油努力呢！路漫漫其修远兮，吾将上下而求索！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再看 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%86%8D%E7%9C%8B-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[所谓博客，不过孤芳自赏 前言在这篇中，我们再谈 JVM 的编译常量、ClassLoader 、和系统类加载器。通过代码实例来理解掌握三者的奥秘。请带上你的好奇心哦~ 编译常量和变量与初始化关于static和final变量对类的初始化到底有什么影响，他们的使用也是面试中经常的考点。首先来看一道程序：1234567891011121314package stormwangxhu.example;class FianlTest&#123; //x是一个编译时常量 public static final int x =6/3; static &#123; System.out.println("FinalTest static block"); &#125;&#125;public class StaticAndFinalTest &#123; public static void main(String[] args) &#123; System.out.println(FianlTest.x);// x=2。static代码块没有执行。 &#125;&#125; 123456789101112131415161718package stormwangxhu.example;import java.util.Random;class FianlTest2&#123; //注意此处，x是编译时变量，即在运行时才能确定x的值。 public static final int x = new Random().nextInt(100);//产生一个0到99的随机数 static &#123; System.out.println("FinalTest2 static block"); &#125;&#125;public class StaticAndFianlTest2 &#123; public static void main(String[] args) &#123; System.out.println(FianlTest2.x); //FinalTest2 static block 先执行static代码块 //43(每次执行不一样) 后执行编译变量 &#125;&#125; 那么，程序的输出是不是出乎你的意料呢，当static和final 修饰的是一个编译时常量时，那么其在初始化阶段就已经确定。所以其初始化将按顺序进行初始化。而对于编译时变量，在初始化阶段并不能确定其具体的值，所以初始化阶段会先初始化类变量，再在程序运行期间进行编译变量的执行。 再看类初始化初始化子类在第一篇博文中我很清楚自己这样写道：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。那么对于这句话我们来看一个实例： 123456789101112131415161718192021222324package stormwangxhu.example;class Parent&#123; static int a =3 ; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println(Child.b); &#125;&#125; 那么这道题的答案是多少呢？若你理解了那句话，答案会很快知晓： 1234StaticTest1 static blockParent static blockChild static block4 还有，当一个类的父类被同一个加载器加载过后，便不会再去加载这个类。 1234567891011121314151617181920212223242526package stormwangxhu.example;class Parent&#123; static int a =3 ; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println("-----------------------------------------"); System.out.println(Parent.a); System.out.println(Child.b); &#125;&#125; 那么，这样又会输出什么呢？ 123456StaticTest1 static block-----------------------------------------Parent static block3Child static block4 为什么会输出这样呢？因为同一个类加载器对加载过的父类若已经加载过，则不再进行加载。但是若是两个不同的类加载器则依旧会执行。 因此我们得出结论：程序中对子类的主动使用，会导致父类被初始化；但对父类的主动使用并不会导致子类初始化。一个最简单明了的例子就是：不可能说生成一个Object 对象就导致系统中所有子类都会被初始化。 再谈类的主动使用首先我们说明结论：只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。 什么意思呢？我们来看代码： 12345678910111213141516171819202122232425262728293031package stormwangxhu.example;class Parent&#123; //静态变量 static int a =3 ; static &#123; System.out.println("Parent static block"); &#125; //静态方法 static void doSomething()&#123; System.out.println("do something"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println(Child.a); Child.doSomething(); &#125;&#125; 来看结果： 1234StaticTest1 static blockParent static block3do something 从结果可以看出，根本就没执行Child ，也就意外根本没有初始化。我们再来理解给出的结论，类变量a 它是在类中定义的，静态方法doSometing() 也是在父类中定义的，所以用子类打印出a 的值，就不是对子类的一个主动使用，而是对父类的一个主动使用。 再谈类加载ClassLoader结论：调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 1234567891011121314151617181920package stormwangxhu.example;class CL&#123; static &#123; System.out.println("Class CL"); &#125;&#125;public class ClassLoaderTest1 &#123; public static void main(String[] args) &#123; ClassLoader classLoader=ClassLoader.getSystemClassLoader(); try &#123; Class&lt;?&gt; clazz=classLoader.loadClass("stormwangxhu.example.CL");//不会导致初始化 System.out.println("------------------------------------"); clazz=Class.forName("stormwangxhu.example.CL");//反射，会导致类的初始化 &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 再看结果： 12------------------------------------Class CL 也就是主动使用除了6种情况下会导致类的主动使用而被初始化，其他的都不会导致类的初始化。 深解双亲委托机制 根类加载器该加载器无父类加载器，实现依赖于底层操作系统，属于虚拟机的一部分，并没有继承java.lang.ClassLoader 。负责加载虚拟机的核心类库，如java.lang.*等。 拓展类加载器加载拓展API 系统类加载器加载CLASSPATH路径下定义的Class。 ClassLoader加载流程所以一个程序启动时，是怎么加载的呢？我们一起来看看： 当运行一个Java程序的时候，JVM 启动，运行启动类加载器，该加载器（ClassLoader）加载核心的API（拓展类加载器和系统类加载器也在此时被加载），然后调用拓展类加载器加载拓展API，最后系统类加载器加载CLASSPATH目录下定义的Class。以上就是一个程序最基本的加载流程。 再看代码： 12345678910111213141516171819202122protected synchronized Class loadClass(String name ,boolean resolve)&#123; //首先检查该name指定的class是否被加载 Class c=findLoadedClass(name); if (c==null)&#123;//c为空，说明该类没有被加载过 try &#123; if (parent!=null)&#123; //若parent不为null，则调用parent的loadClass进行加载 c=parent.laodClass(name,false); &#125;else &#123; //parent为null，则调用启动类加载器进行加载 c=findBootstarpClass0(name); &#125; &#125;catch (ClassNotFoundException e)&#123; //若仍然无法加载成功，则调用自身的findClass进行加载 c=findClass(name); &#125; &#125; if (resolve)&#123; resolveClass(c); &#125; return c; &#125; 以上可以看出一个类的加载使用了双亲委托模式。 为什么要使用双亲委托模型我们为什么要使用双亲委托模型呢？记得阿里第一面就问我，我当时表达不出来。 原因一：可以避免重复加载，当父类已经加载了该类的时候，就没有必要子ClassLoader 再加载一次 原因二：考虑到安全因素，若不使用这种委托模式，那么可以随时用自定义得String 来动态替代Java核心API 中定义的类型，这样会存在非常大的隐患，而父类委托的方式就可以避免这种情况，因为String 已经在启动时被加载，所以， 用户自定义是无法加载一个自定义的ClassLoader ClassLoader一些重要方法loadClass方法ClassLoader.loadClass() 是ClassLoader 的入口点。定义如下： 1Class loadClass(String name,boolean resolve); 1、name 是JVM需要的类的名称，如：java.lang.Object 。 2、resolve 参数告诉方法是否需要解析类。在准备执行该类前，应该考虑解析。注意：并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那就不需要解析。 findClass方法loadClass 默认实现调用这个新方法。findClass的用途包含ClassLoader 的所有特殊代码，而不须复制其他代码（例如：当专门的方法失败时，调用系统的ClassLoader） 目的是：从本地文件系统使用实现的类加载器加载一个类。为了创建自己的类加载器，应该拓展ClassLoader类，这是一个抽象类。可以创建一个FileClassLoader extends ClassLoader，然后覆盖ClassLoader中的findClass(String name)方法，这个方法通过类名得到一个Class对象。 1234public Class findClass()&#123; byte[] date =loadClassData(name); return defineClass(name,data,0,data.length);&#125; defineClass方法defineClass方法接受由原始字节组成的数组，并把它转换成Class对象。原始数组包含从文件系统或网络装入的数据。defineClass管理JVM的许多复杂的实现层面——它把字节码分析成运行时数据结构。检验有效行等。因为defineClass方法被标记为final，所以不能覆盖它。 forName方法Class类中有一个静态方forName，这个方法和ClassLoader中的loadClass方法目的一样，都是用来加载class的，但是两者在作用上有所区别。 先来看看看forName()方法： 1Class clazz = Class.forName("something"); 或者： 12ClassLoader c1 =Thread.currentThread().getContextClassLoader();Class clazz= c1.loadClass("something"); Class.forName()调用Class.forName(name,initialize,loader); 也就是Class.forName(&quot;something&quot;) 等同于Class.forName(&quot;something&quot;,true,CALLCLASS.class.getClassLoader()); 。 解释： 第二个参数”true”，用于设置加载类时是否连接该类，即加载中的连接阶段，true就连接，否则就不连接。 再看看loadClass()方法： loadClass方法定义是protected，也就是说，该方法是被保护的，而用户使用的方法是一个参数，一个参数的loadClass方法实际上就时调用了两个参数，第二个参数默认是false。因此，在这里可以看出通过loadClass加载类实际上就是加载的时候并不对该类解析 因此不会初始化该类。而Class的forName方法则相反，使用forName加载的时候就会将Class进行解析和初始化。 你知道JVM 使用什么字符吗？答案是：Unicode characters java开发者必须牢记：在java中字符只以一种形式存在，那就是Unicode（不选则任何特定的编码，直接使用它们在字符集中的编号，这就是统一的唯一的方式）。 那么“在java中”到底是指哪里呢？是指在JVM中、在内存中、在我们写的代码里声明的每一个char、String类型的变量中。 JVM 这种的约定使得一个字符分为两部分：JVM 内部和OS 的文件系统。在JVM 内部，统一使用Unicode表示，当这个字符被从JVM 内部移动到外部（即保存为文件系统中的一个文件内容时），就进行了编码转换，使用了具体的编码方案。因此可以说，所有的编码转换只发生在边界的地方，JVM 和 OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。 Windows中默认字符是GBK，在面向字符流时，Reader和Writer只会使用这个默认的编码来转换，而不能为一个Reader和Writer指定转换时使用的编码。这意外着，若使用中文版Windows系统，其中存放了一个UTF-8编码的文件，当采用Reader类读入的时候，他还会使用GBK来转换，转换后内容当然不对！所以在需要GBK以外的编码时，就必须采用编码转换：一个字符与字节之间的转换。因此I/O系统中能够指定转换编码的地方，也就是字符和字节转换的地方。那就是InputStreamReader 和OutputStreamWriter。这两个类是字节流和字符流之间的适配器，他们承担着编码转换的地方。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 JVM 垃圾收集器和内存分配策略]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%88%9D%E6%8E%A2-JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[所谓博客，不过孤芳自赏 前言 Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。 本篇博文主要输出JVM的常见垃圾回收算法（也就是面试官长问到的GC），以及在 JVM 虚拟机中，JVM 是如何判断对象的有效性、对象在内存中是按照什么规则存放的，请带上你的好奇心慢慢往下读。 在JVM内存区域中，属于线程私有的程序计数器、虚拟机栈和本地方法栈这个3个区域随着线程而生而死。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。每一个栈帧要分配多少内存基本在类结构基本确定下来时已经确定。因此这几个区域的内存分配和回收都具有确定性，无需过多考虑回收问题，因为方法或者线程结束时，内存自然就跟着回收了。 其实，我们关心的是JVM 中的线程共享数据区：Java 堆和方法区。这部分的内存分配和回收都是动态的，而垃圾收集器所关注的就是这部分内存。那么在这两个区域中，JVM 是如何进行内存分配和回收的呢？我也很好奇~。 我们先看堆中，再看方法区！ 我们知道，在Java堆中，存放着Java世界几乎所有的对象实例，垃圾回收器在对堆进行回收之前，第一件事情就是需要知道这些对象“死”还是“活”着，如何知道，JVM 使用引用计数法、可达性分析算法进行判断。 看”堆”中判断对象生死法宝首先，无论是现在要说的引用计数算法，还是后文的可达性分析算法，都和对象的引用有关，该算法的目标对象就是引用。说该算法前，就不得不说引用了。 再谈引用其实，判定对象的存活都与引用有关，在Jdk 1.2 之后，Java对引用扩充如下：分位强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这4种引用强度依次逐渐减弱。 强引用：程序代码中普遍存在的引用，只要该引用存在，垃圾收集器永远不会回收掉被引用的对象。 1Object obj=new Object(); 软引用：描述有用但非必需的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。 弱引用：是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 引用计数算法什么是引用计数法？很多人这样说到：每一个对象中都添加一个引用计数器，当该引用被一个地方引用一次，就+1；引用失效时，就-1。当计数器为0时，说明该对象不可能再被使用。 客观说，引用计数算法，实现简单、效率高，大部分情况下很不错，如微软COM技术等在应用。但Java虚拟机里却没有选用该算法，最主要原因是：很难解决对象之间相互循环引用问题。即两个引用引用着对方的实例对象。 可达性分析算法主流程序语言：Java、C# 都使用可达性分析算法来判断对象是否存活。这就很牛逼了，到底是什么样的算法，竟然被Java用来判断对象是否存活了。 可达性分析算法基本思路：通过一系列的称为GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 （Reference Chain）,当一个对象到GC Roots 没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的； 从下图来看：对象object5,6,7虽然相互关联，但是他们到GC Roots是不可达的，所以它们将会被判定为是可回收对象。 那么，可作为GC Roots对象有哪些？一般从栈和方法区去思考： 栈： 虚拟机栈（栈帧中的本地变量表）中引用对象。 本地方法栈中JNI（一般来说的Native方法）引用的对象。 方法区： 类静态属性引用的对象。 常量引用的对象。 再来对比看一下，熟记他们。下图所示： 以上就是堆中关于JVM判断对象是否存活的两个算法，和我说一遍：引用计数算法——可达性分析算法。 再看”方法区”垃圾收集方法区中垃圾回收对象主要为两个：废弃常量和无用的类。 废弃常量与堆中回收对象非常类似（简单）。但判断是否无用类即比较苛刻。 判定一个类是否是无用的类条件相对苛刻： 该类所有实例都已被回收，即Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。 在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此； 常见GC算法你了解吗垃圾收集算法实现设计大量细节，各个平台操作虚拟机内存方法不一样，所以只说算法思想。 标记-清除 算法如同其名字一样，该算法（最基础收集算法）分两步：标记——&gt;清除。 标记：标记的是什么？其实标记的是所有需要回收对象。 清除：清除什么？清除上一步被标记的需要回收对象。 从上图可以看出：被标记的对象被清除了。但也发现了两个不足：效率问题、空间问题。 效率问题：标记、清除连个过程效率都不高。 空间问题：清除后产生大量不连续内存碎片。如若分配较大对象时，则无法找到足够连续内存而不得不提前触发另外一次垃圾回收动作。 复制 算法为了解决 标记-清除 算法带来的效率问题，复制算法应用而生。 算法思想：将可用内存按容量划分为大小相等两块，每次只使用其中一块。 复制：复制什么？一块内存用完后，复制其中存活对象到另一块。复制存活~复制存活~复制存活~ 优点：每次对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效； 不足：提高效率的代价是将内存缩小到原来的一半。 现代商业虚拟机都采用这种收集算法来回收新生代。HotSpot虚拟机将内存划分为Eden 和2个Survivor 空间，比例8:1:1。每次只是用Eden 和一个Survivor 空间。回收时，将Eden 和Survivor 中还存活对象复制到另外一块Survivor 空间中。当Survivor 空间不足时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion），让对象进入老年代。分配担保机制后文中会说到。 标记-整理 算法标记整理算法，也是一样，分2个过程。标记——整理 标记：标记什么？标记需要被回收对象。 整理：此处不像清除，将其清除掉，而是让所有存活对象都向一端移动，然后清理掉端边界以外内存。 所以，标记清除算法和标记整理算法可以比较吗？试试： 分代收集 算法分代收集算法并没有什么心思想，只是根据对向存活周期不同，将内存划分为几块。一般讲 Java 堆分为新生代和老年代。 新生代和老年代有什么特点呢？ 新生代：对象大批会死去，少量存活。 老年代：对象存活率高。因此对于新生代和老年代特点可采用不同回收算法。 新生代：复制算法。复制少量存活对象 老年代：标记-清理 或 标记-整理 算法。标记需回收对象。 如果你有耐心读到此处，恭喜你，已经从理论层面了解了3个垃圾回收算法。我们一起回顾一下其名称： 标记-清除 算法，复制 算法，标记-整理 算法。 那么接下来，在知道了垃圾回收算法后，就要从应用层面去了解垃圾回收算法的应用 （垃圾回收器）。所以，一起看看常见垃圾收集器有什么？:kissing: 常见垃圾收集器异同你说上来吗 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。此次讨论Jdk 7之后 HotSpot 虚拟机包含的几个收集器。 Serial 收集器 新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。 使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值） ​ ​ ParNew 收集器 新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。 使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器 新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%， 这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。 使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）； 使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。 使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效）， 用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。 Serial Old 收集器 老年代收集器，单线程收集器，串行， 使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法， 使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程）， 在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。 CMS 收集器 老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收， 优先使用ParNew+CMS，当用户线程内存不足时，采用备用方案Serial Old收集。 CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) –&gt;预清理(CMS-concurrent-preclean)–&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset) 在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。 CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。 使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。 CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 G1 收集器G1 收集器是一款面向服务器端应用的垃圾收集器，计划未来替代CMS收集器。相比其他GC收集器，G1 具备如下特点： 并行与并发：能充分利用多CPU、多核环境下的硬件优势； 可以并行来缩短”Stop The World”停顿时间； 也可以并发让垃圾收集与用户程序同时进行； ​分代收集：收集范围包括新生代和老年代 ， 能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象； 虽然保留分代概念，但Java堆的内存布局有很大差别； 将整个堆划分为多个大小相等的独立区域（Region）； 新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。 空间整合：结合多种垃圾收集算法，空间整合，不产生碎片。从整体看，是基于标记-整理算法； ​ 从局部（两个Region间）看，是基于复制算法； 这是一种类似火车算法的实现； 都不会产生内存碎片，有利于长时间运行； ​可预测的停顿：低停顿的同时实现高吞吐量， G1除了追求低停顿处，还能建立可预测的停顿时间模型； 可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒； ​ G1 收集器运作大致可划分为如下几个步骤： 初始标记 并发标记 最终标记 筛选回收 应用场景：面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； 在下面的情况时，使用G1可能比CMS好：​ （1）、超过50％的Java堆被活动数据占用；​ （2）、对象分配频率或年代提升频率变化很大；​ （3）、GC停顿时间过长（长于0.5至1秒）。​ 是否一定采用G1呢？也未必：​ 如果现在采用的收集器没有出现问题，不用急着去选择G1；如果应用程序追求低停顿，可以尝试选择G1； 是否代替CMS需要实际场景测试才知道。 内存分配与回收策略你知道吗Java 体系中所提倡的自动内存管理最终可以总结为自动化解决两个问题： 给对象分配内存以及回收分配给对象的内存。 内存回收上面已经讲述，下面一起看看关于对象分配内存的那点事儿。 对象的内存分配，大方向说，就是往堆上分配，对象主要分配到1新生代的Eden区上，若启动本地线程分配缓冲，将按线程优先在TLAB 上分配。少数情况下也可能会直接分配到老年代中。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间进行分配时，虚拟机将进行一次Minor GC。 此处，我们先来了解一下常说的 Minor GC 和 Full GC 有什么不一样吗？ 新生代GC （Minor GC：速度快）：指发生在新生代的垃圾收集动作，因Java 对象大多数都具备招生夕灭特性，所以Minor GC 会非常频繁，一般回收速度也比较快。 老年代GC （Major GC/Full GC：速度慢）：指发生在老年代的GC ，出现了 Major GC，经常会伴随至少一次的Minor GC（但非绝对），Major GC 速度一般比Minor GC 慢10倍以上。 大对象直接进入老年代大对象，大对象，什么标准才是大对象？大对象是指：需要大量连续内存空间的Java对象。最典型大对象是：很长的字符串和数组。大对象对虚拟机来说是一个坏消息，因为出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够连续空间“安置”他们。 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器。那么对象的年龄是怎么计算的呢？ 计算方法：对象在Eden 出生并经过第一次Minor GC后仍然存活，并且能被Survivor 容纳的话，并被移动到Survivor 空间中，则对象年龄设置为1.对象每在Survivor “熬过” 一次Minor GC，年龄+1岁，当他年龄增加到一定程度（默认15岁），就会晋升到老年代中。 动态对象年龄判定如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。关于这句话的理解，请多读两遍就理解了~~~。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC. 总结哇哦，读到此处，是不是有点儿心累，其实我也心累，但相比于此处你获得的知识，是不是感觉一下又阳光明媚了。我们在此处再闭眼回想一下，我们学到的东西： （1）理论层面： 判断对象死活算法：引用计数算法——-可达性分析算法。 垃圾收集算法：标记-清除 算法、复制 算法、标记-整理 算法。 （2）应用层面： 垃圾收集器：balabalabala~~~~。相信你已经知道了。 （3）对象进入内寸分配策略： 首先：Eden区优先 然后：大对象去哪儿？——直接进入老年代。 最后：长期存活对象去哪儿？——先长大到默认年龄15岁，再进入老年代。 到此，我们的学习就结束了，在博文中出现的错误或疑问，欢迎和我交流。 GitHub]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM 垃圾收集器</tag>
        <tag>内存分配策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 Java 的内存模型]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%88%9D%E6%8E%A2-Java-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言上一篇博文中叙述了JVM的内存区域，而与之相似的是Java内存模型。其实JVM与JMM两者之间并不是同一个层次的划分，这两者基本是没有关系的。 但硬要说出点关系，则从变量、主内存、工作内存定义看，对应关系如下： 主内存 ——-&gt; Java堆中对象实例数据部分 工作内存 ——–&gt; 虚拟机栈中部分区域 从更低层次说，对应关系如下： 主内存 ——-&gt; 物理硬件内存 工作内存 ——–&gt; 优先存储于寄存器和高速缓存中（程序运行时主要访问读写的是工作内存） 计算机硬件效率与一致性 ​ 处理器、高速缓存、主内存之间关系 Java 内存模型Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。 定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133[2]）发布后，Java内存模型已经成熟和完善起来了。 主内存和工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示： ​ 线程、主内存、工作内存三者的交互关系 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题后文会讲）。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作。 如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。 注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在后文将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。 注：基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了（仅是描述方式改变了，Java内存模型并没有改变）。 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用 synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。 当一个变量定义为volatile之后，它将具备两种特性 （可见性、禁止指令重排序）。 （1）、保证此变量对所有线程的可见性。 这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因。 12345678910111213141516171819202122232425262728293031public class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; // 等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) Thread.yield(); System.out.println(race); &#125;&#125; 这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？ 问题就出现在自增运算race++ 之中，我们用Javap反编译这段代码后会得到代码，发现只有一行代码的increase（） 方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic 指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic 指令执行后就可能把较小的race值同步回主内存之中。 1234567891011public static void increase（）；Code：Stack=2，Locals=0，Args_size=00：getstatic#13；//Field race：I3：iconst_14：iadd5：putstatic#13；//Field race：I8：returnLineNumberTable：line 14：0line 15：8 客观地说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析。 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 而在像如下的代码清单所示的这类场景就很适合使用volatile变量来控制并发，当shutdown（）方法被调用时，能保证所有线程中执行的doWork（）方法都立即停下来。 123456789volatile boolean shutdownRequested；public void shutdown（）&#123; shutdownRequested=true；&#125;public void doWork（）&#123; while（！shutdownRequested）&#123; //do stuff &#125;&#125; 注：上面这段话到底怎样理解呢？我是这样理解的：其实，Java 内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖于主内存作为传递媒介方式实现可见性。即volitile关键字保证可见性是通过以主内存为媒介进行传递的。 （2）、禁止指令重排序优化。 普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。 上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码清单: 1234567891011121314151617Map configOptions；char[]configText；//此变量必须定义为volatilevolatile boolean initialized=false；//假设以下代码在线程A中执行//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions=new HashMap（）；configText=readConfigFile（fileName）；processConfigOptions（configText,configOptions）；initialized=true；//假设以下代码在线程B中执行//等待initialized为true，代表线程A已经把配置信息初始化完成while（！initialized）&#123; sleep（）；&#125;//使用线程A中初始化好的配置信息doSomethingWithConfig（）； 上述程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义initialized 变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码initialized=true” 被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。 指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，笔者再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。 12345678910111213141516171819public class Singleton &#123; private volatile static Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Singleton.getInstance(); &#125;&#125; 编译后，这段代码对instance变量赋值部分如代码清单 1234567890x01a3de0f：mov$0x3375cdb0，%esi ；……beb0cd75 33 ；&#123;oop（'Singleton'）&#125;0x01a3de14：mov%eax，0x150（%esi） ；……89865001 00000x01a3de1a：shr$0x9，%esi ；……c1ee090x01a3de1d：movb$0x0，0x1104800（%esi） ；……c6860048 1001000x01a3de24：lock addl$0x0，（%esp） ；……f0830424 00 ；*putstatic instance ；-Singleton：getInstance@24 通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150（%esi）这句便是赋值操作）多执行了一个lock addl ＄0x0，（%esp） 操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。这句指令中的addl ＄0x0，（%esp） （把ESP寄存器的值加0）显然是一个空操作（采用这个空操作而不是空操作指令nop是因为IA32手册规定lock 前缀不允许配合nop指令使用），关键在于lock前缀，查询IA32手册，它的作用是所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。 那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10）2与A2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock addl＄0x0，（%esp） 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。 解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 注：上面这段话又怎样理解？volitile关键字它也有使用场景，它的读操作相比于普通变量无区别。但写操作会慢，因为它需要插入许多内存屏障禁止指令重排序。 注：volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复，此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题），这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因。 对于 long 和 double 型变量的特殊规则Java 内存模型对64位数据类型（long 和 double） ：允许虚拟机将没有被volitile关键字修饰的64位数据类型读写操作分两次32位操作来进行。这就是所谓的long和double的非原子性协定 。 再看 Java 内存模型的3个特征 原子性 可见性 有序性 原子性Java 内存模型中尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供更高层次字节码指令monitorenter 和 monitorexit 来隐式使用，这两个字节码指令反应到java代码就是—–synchronized关键字，因此在synchronized块之间的操作也具有原子性。 可见性什么是可见性？即一个线程修改了共享变量值，其他线程能够立即得知这个修改。 如何实现？当然是通过volitile 关键字保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。这也是volitile 变量与普通变量的区别所在！ 还有2个关键字能实现可见性：synchronized 和 final 。 实现机制又是怎样的？简单总结： （1） synchronized （同步块的可见性）：对一个变量进行unlock（多线程操作共享变量，每个线程须lock，unlock该变量。）操作之前，必须先把此变量同步回主内存中（执行store 、write 操作）。 （2） final ：被final 关键字修饰的字段在构造器中一旦初始化完成，且没有把 this 引用传递出去，那么其他线程就能看见final 字段的值。 有序性Java 内存模型有序性 在前面讲解volitile关键字已详细讲解。Java 中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。 前半句指：线程内表现为串行的语义。后半句指：”指令重排序“现象和”工作内存和主内存同步延迟“现象。 Java 语言用volitile和synchronized两个关键字保证线程之间操作有序性。volitile 关键字本身就包含了禁止指令重排序语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得。 介绍完3种特性后是不是发现，synchronized关键字是“万能”的。但是越“万能”的并发控制，通常会伴随着越大的性能影响。在后续博文会说。 总结前面说了这么多，就以下内容： 1、Java 内存模型是怎样的一个工作原理？ 2、内存间是怎么样交互进行信息传递的？ 3、volitile 关键字到底是如何保证一个共享变量的可见性、又如何做到禁止指令重排序，从而保证代码在多线程条件下顺序执行？ 基于以上三个问题，我们做了长篇幅的解释，大体原理可说明说下：1、Java 内存模型原理： 2、共享变量通过以主内存作为媒介，在多线程间进行交互。 3、 （1） 保证可见性：lock 前缀，将使得本CPU的Cache（高速缓存）写入了内存，该写入动作也会引起别的CPU或者别的内核 无效化 （Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。 （2）、禁止指令重排序：增加内存屏障。（lock前缀 ）]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java 内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道题看清 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F05%2F%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8B%E6%B8%85-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[所谓博客，不过孤芳自赏 前言首先，我说的是一道题要看清JVM的类加载机制，所以，我们得先有题呀，一起来看一道经典的面试题： 123456789101112131415161718192021222324252627282930313233343536373839404142class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; //注意此处位置 Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; //注意此处位置 private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; 这道题，看似没有什么差别，但其实，差之毫厘谬以千里，结果会完全不同，但结果究竟是怎么样的呢？我现在还暂时不能告诉你，除非你自己在编译器上运行一下。跟着我一起来看看JVM的类加载机制吧，看完后，你一定会自己说出正确的答案，而且理解其所以然，真真的一道题看清JVM的来世今生！来吧！ 类加载的过程概念虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象） 类的生命周期关于类的生命周期，请记住这句话：加载–&gt;连接–&gt;初始化。 一个类从出生到卸载完会经历以下的生命周期： 类从被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（UnLoading）7个阶段。其中，验证、准备、解析三个阶段又统称为连接（Linking）。可总结为：加载、连接、初始化！ 下面看看这7个过程中（5个阶段）虚拟机进行了哪些动作？ 加载阶段通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 上面这句话是什么意思呢？其实很简单，就是将一个.class 文件通过类加载器，加载到内存中，在方法区保存其类的数据结构，然后在堆中创建该类的对象。该对象又作为访问方法区中该类数据结构（即各种数据）的访问入口。即访问入口是该对象。 即：查找并加载类的二进制数据文件。 连接阶段 验证： 为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证 即：确保被加载类的正确性 准备： 正式为类变量（即static修饰的变量，包括静态代码块）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配 即：为类的静态变量分配内存，并将其初始化为默认值 解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用是二进制数据中引用，直接引用相当于运行期间的指针，指向方法区内存位置。 即：把类的符号引用转换为直接引用 初始化阶段类初始化阶段是类加载过程的最后一步。前面的类加载过程中，除了在加载阶段用户可以使用自定义的类加载器参与外，其余动作完全由虚拟机主导和控制！初始化阶段就是执行类构造器()方法的过程。到了初始化阶段，才真正开始执行类中定义的Java代码（或者说是字节码）！ 静态变量初始化有两种路径： （1）、在静态变量声明处初始化。 （2）、在静态代码块中初始化。 使用阶段开始使用类。 卸载阶段使用完后，卸载类。 关于类加载加载主要是将.class 文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 其中获取.class 文件主要有以下几种方式： ZIP jar（这也是为什么我们在开发中可以使用别人的jar包原因，也是常见加载.class 文件方式） 网络下载 类加载需要完成的三件事情：在加载阶段，JVM需要完成3件事：经历过程如下： 即获取字节流——&gt;方法区——-&gt;Java堆中。 通过类的全限定名获取该类的二进制字节流（即包名+类名）； 将字节流所代表的静态存储结构转化为方法区的运行时数据结构（即将类的数据结构存储于方法区中）； 在堆中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 注：何时会触发类的加载过程，Java虚拟机规范中并没有进行强制约束，而是交给虚拟机的具体实现来自由把握。即然知道了类加载需要完成三件事情，接下来就得知道类加载器是干什么的了。 类加载器虚拟机设计团队把类的加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何获取所需要的类而实现这个动作的模块称为“类加载器”。 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。更通俗的说，也就是：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals()、isAssignableFrom()、isInstance()等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 下面我们用代码来解释一下： 1234567891011121314151617181920212223242526272829303132333435363738394041package stormwangxhu.example;import java.io.IOException;import java.io.InputStream;/** * @author stormwangxhu * @date 2018/04/06 */public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String filename = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(filename); if (inputStream == null) &#123; return super.loadClass(name); &#125; byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; try &#123; Object object=myClassLoader.loadClass("stormwangxhu.example.ClassLoaderTest").newInstance(); System.out.println(object.getClass());//class stormwangxhu.example.ClassLoaderTest System.out.println(object instanceof stormwangxhu.example.ClassLoaderTest);//false &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 我们解释一下上述结果产生的原因： 因为虚拟机种存在了两个ClassLoaderTest的类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然返回false。 若从JVM的角度来看，类加载器可以分为： 启动类加载器(Bootstrap ClassLoader，它负责加载存放在$JAVA_HOME/jre/lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar）。启动类加载器是无法被Java程序直接引用的。很容易可以验证，执行System.out.println(String.class.getClassLoader())打印结果为null) 扩展类加载器(Extension ClassLoader, 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载$JAVA_HOME/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。在jdk1.9中类加载器有所变化！1.9中jdk.internal.loader.ClassLoaders$PlatformClassLoader，称为平台类加载器) 应用程序加载器（系统应用程序类加载器）(Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径ClassPath所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。注意在jdk1.9中，应用程序加载器由jdk.internal.loader.ClassLoaders$AppClassLoader实现) 我们的应用程序都是由这3种类加载器相互配合进行加载的，若有必要，可以加入我们自己定义的类加载器。其中 启动类加载器是由C++语言编写的，其他两个由Java编写。 这些类加载器之间的关系又引出双亲委托机制。 借此机会，我们来看看什么是双亲委托机制！ 双亲委派模型类加载器之间的关系如图所示： 上图所展示的类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 双亲委派模型工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如：类java.lang.Object类存放在$JAVA_HOME/jre/lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这便保证了Object类在程序中的各种类加载器中都是同一个类。相反：若没有使用双亲委派魔性，由各个类加载器自行去加载的话，若用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也无法得到保证，应用程序也将会一片混乱。 此处，我们看看ClassLoader 这个抽象类的双亲委派机制的实现了！该代码都集中在java.lang.ClassLoader 的loadClass 方法之中。 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded，首先，检查请求的类是否已经被加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // 若父加载器抛出ClassNotFoundException，说明父类加载器无法完成加载该类请求 // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // 在父类加载器无法加载的时候， // 再调用自身的findClass来进行类的加载 // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 对照我们上面的测试代码自定义的那个类加载器，如果是实现findClass()而没有实现loadClass()方法，那么加载时候先开始判断它的父类加载器(自定义类加载器的上一级是应用程序类加载器，然后根据双亲委托机制一步一步进行判断加载。最后加载都不成功就会调用findClass()方法来加载，jdk1.2之后官方不提倡实现loadClass()！上面的例子，为了测试两个Class对象不相等，强制实现了loadClass()，因为如果只实现findClass(), 就会被应用类加载器所加载。 注：一般由启动类加载器加载的对象以返回null 来表示该类是由根类加载器加载的。若非根类，则会打印出相关信息。 关于验证验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。虚拟机如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。验证阶段会完成以下4个阶段的检验动作： 文件格式验证 ：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证(是否符合Java语言规范) ：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 字节码验证（确定程序语义合法，符合逻辑） ：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证（确保下一步的解析能正常执行）：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 ​ 关于准备准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段有两个容易混淆的概念，首先，进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，实例变量是在对象实例化的时候分配在Java堆中的。其次这里所说的初始值“通常情况”下是数据类型的零值。 那么问题来了，到底是什么意思呢？其实就是类变量系统为其设置的默认值，而不是程序员通过代码的初始值。 假如我们定义了一个类变量public static int value = 123; 那么，变量value 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value 赋值为123的putstatic 指令是在程序被编译后，存放于类构造器&lt;clinit&gt;() 方法之中，所以把value 赋值为123的动作将在初始化阶段才会执行。 若有个多个静态变量，则依次按顺序分配空间并赋值。 关于各种类型的初始值： 上面说到，在”在通常情况”下初始值为零值，那么相对来说就会有一些“特殊情况”：若类字段的字段属性表中存在ConstantValue 属性，那么在准备阶段变量value 就会被初始化为ConstantValue 属性所指定的值，假设上面类变量定义为： public static final int value=123; 编译时Javac将会为value 生成ConstantValue 属性，在准备阶段虚拟机就会根据ConstantValue 的设置value 赋值为123。 关于解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 对于解析和验证这一块，和读懂Class文件有着密不可分的关系，所以这一块的补充知识会在读懂Class文件字节码之后进行讲解！ 关于初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源。 或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中(static{})的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 ()方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 ()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 注：上面说了这么多，我们脑海中必须有个概念，类变量从加载到初始化被赋值了几次？读到这里，我们应该清楚的认识到，至此，类变量已经被赋值也只能被赋值两次了。 第一次是：连接阶段的准备，赋予类变量系统初始值。 第二次：初始化阶段，赋予程序员给其赋的值。 这里我们再说一下类变量初始化，类变量初始化时按其顺序执行，什么意思呢？看一段代码： 1234567891011121314package stormwangxhu.example;public class staticTest &#123; static int a=1; static &#123; a=2; &#125; static &#123; a=6; &#125; public static void main(String[] args) &#123; System.out.println("a = "+a); &#125;&#125; 这段代码输出结果会是什么呢？1 ？2？还是6。如果你毅然而然的回答了6，那么恭喜你，你真的很6，答案就是6。其原因就是类变量在准备阶段被赋予初始值后，在初始化阶段按其顺序依次向下执行。 类的初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接。 假如类存在志杰的父类，且这个父类还没有被初始化，那就先初始化直接的父类。 假如类中存在初始化语句，那就依次执行这些初始化语句。 那么Java程序对类的使用主要有两种方式，对类的主动使用和被动使用。除了以下几种Java程序主动使用类时需要进行初始化，其余都为被动使用，不会导致类的初始化。 类得初始化时机（主动使用6种） 使用new 创建类的实例； 读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）。 调用类的静态方法。 反射 Class.forName(“xxxx”)。 初始化一个类的子类。 有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 注：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。 （1）、在初始化一个类时，并不会 先初始化它所实现得接口。 （2）、在初始化一个接口时，并不会初始化它的父接口。 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 被标明为启动类的类（即包含main()方法的类）要初始化； 当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上情况称为对一个类进行主动引用，且有且只要以上几种情况（主动使用）需要对类进行初始化。 此处，是时候去解释我们的那道经典面试题了! 面试题答案解析1234567891011121314151617181920212223242526272829303132333435363738394041class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; Singleton输出结果：1 0 原因： 1 、首先执行main中的Singleton singleton = Singleton.getInstance();2、 类的加载：加载类Singleton3、 类的验证4 、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值05、 类的初始化（按照赋值语句进行修改）：执行private static Singleton singleton = new Singleton();执行Singleton的构造器：value1++;value2++; 此时value1，value2均等于1执行public static int value1;public static int value2 = 0;此时value1=1，value2=0 Singleton2输出结果：1 1 原因： 1、 首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2();2、 类的加载：加载类Singleton23、 类的验证4、 类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null,5、 类的初始化（按照赋值语句进行修改）：执行public static int value2 = 0;此时value2=0(value1不变，依然是0);执行private static Singleton singleton = new Singleton();执行Singleton2的构造器：value1++;value2++;此时value1，value2均等于1,即为最后结果 总结上面说了这么多，如果你有耐心一句一句读完，相信你已经对JVM类加载机制有了一定的认识，那么在面试中，此处有什么考点呢？继续看总结。 JVM类加载机制常见面试问题类的生命周期加载—&gt;连接—&gt;初始化—&gt;使用—&gt;卸载 Java类加载器启动类加载器（C++）—&gt;拓展类加载器（Java）—&gt;应用程序类加载器（Java）—&gt;自定义类加载器 他们之间的关系为：双亲委托模型 双亲委派模型工作过程 首先会先查找当前ClassLoader是否加载过此类，有就返回； 如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类； 如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。 作用 共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。 隔离功能，保证java/Android核心类库的纯净和安全，防止恶意加载。 打破双亲委托模型 双亲委派模型的逻辑都在loadClass()中，重写loadClass()，一般是重写findClass()的 系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载 自定义类加载器方法 loadClass(String name,boolean resolve)：根据指定的二进制名称加载类 findClass(String name)： 根据二进制名称来查找类 直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader 在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载 ​ 引起类加载操作的五个行为 遇到new、getstatic、putstatic或invokestatic这四条字节码指令 反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化 虚拟机执行主类的时候(有 main(string[] args)) JDK1.7 动态语言支持 Java对象创建时机 使用new关键字创建对象 使用Class类的newInstance方法(反射机制) 使用Constructor类的newInstance方法(反射机制) 使用Clone方法创建对象 使用(反)序列化机制创建对象 结尾JVM的类加载机制，要我来说，也可能有的地方讲的不太正确，如若有疑问或建议，还请各位大佬私信：牛客用户（StormWangxhu)。 再次特意推荐大家去读周志明老师的《深入理解Java虚拟机》，确实不错。 推荐推荐另外一篇文章： JVM 如何从入门到放弃]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记头条 Java 实习第一面]]></title>
    <url>%2F2018%2F03%2F30%2F%E8%AE%B0%E5%A4%B4%E6%9D%A1Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[人生第一次想要在暑假找一个实习来进行锻炼，奈何心有余力不足，技术学的不扎实，在头条第一面，没考算法的前提下，我顺利的挂了，说起来也是心酸。只好再去学了，我知道面试官只是安慰我，说我还有机会，但我也不会气馁！加油吧，少年！ 1.自我介绍 2.HTTP POST GET 区别(不错) 3.端口的作用(可以) 4.HashMap的实现原理(答得不错)，数据量大的时候查询是否影响效率，查询一个元素的时间复杂度(不行) 5.数据库MySQL索引(不行) 6.前后端数据如何传递 7.Ajax(说了了解过) 8.栈中查找最小元素以及栈结构(不行) 9.冒泡排序时间复杂度(不行) 10.问到了项目图书商城实现了哪些功能，怎么想到要做这个项目的。 11例题，实现一个函数，将一个Map分割出来。 面试总结:基础知识，如常见数据结构知识不够完备，基础知识不扎实。虽然第一面挂了，但是明白了要学习的方面。面试官说，头条里语言不管是哪一门都可以，一些常见的基础知识得掌握，评论我有短期目标，也有长期目标挺不错的。 HTTP 中GET POST请求的区别①get请求用来从服务器上获得资源，而post是用来向服务器提交数据； ②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； ③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式； ④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； ⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。 补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。 链接深入理解HTTP协议]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2017%2F12%2F31%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天在微博上看到了这样的文字，2017年12月31日后，1999年12月31日，也是所有的90后都十八了，成为了法定成年人。突然有一种莫名的感受，晚上的时候朋友圈里便刮起了一阵向自己18岁说再见、晒图片的风暴，诉说着自己18岁的模样。我也去空间找了一张那时的模样。18岁，是一个…emmm怎么说呢，一个转折点吧。18岁，我们高三，决战高考，告别高中岁月，踏入大学校门；18岁，告别青涩的青少年时代，步入成年人行列，慢慢的走向成熟和稳重，但也不失18岁前的单纯和无知，但也更多了一些杂事在心头。总之，18岁，无怨也无悔！ 总结一下2017吧，说起这一年，总体大概就分为两个部分吧，学习和生活。 先来说说生活，我想按时间轴来回顾自己的2017！ 2017年1月：1月初，微信小程序正式上线，很新奇。1月中旬，我在大学的第一个寒假里，选择了去和一群人学习。虽然只有短短10天，但每一天，每一个人，都会带来一份惊讶和感动。认识了一帮好人，做了一些终身难忘的事儿。1月21日，我告别了他们，回家了。记得当时，感触很多。 2017年2月：学习完回家后一直和家人待在一起，期间下了一场雪，很开心，在家的时光，没有学校里的快节奏，过得舒心极了。期间，去了一趟银川，见了见老同学，还和田林学长在六盘山门口吃了个饭，快乐的回忆。2月24日，和勇哥一起来到了学校，开启新的一学期，大一下学期。 2017年3月：这个月，新的一学期开始了。3月18日，我们去烧烤了，大一的我们去的人很多，那天是和张明、马林贵、马小军学长骑行去的，回来的时候，一鼓作气，骑回到了学校，和他们同时回到学校。那时候，校园里花正开，好一番景象！ 2017年4月：3月末4月初的学校，春暖花开。每天晚上，学长学姐我们都约着跑步，绕学校一圈，大概5.5公里，跑下来，一天的疲惫都会感觉被汗水带走了。4月，清明节的第一天，我们便开始了来回长达120公里的骑行。一趟周至，转转水街，一路上骑着自行车跟在大部队的后面听歌溜达，时而追赶，时而说笑，反正我记得，骑行来回的三天，我都会发一条朋友圈。4月29号，和高中的几个同学，我们爬了一趟华山，一路上，酸甜苦辣都有，回来一鼓作气还写了一篇文章，发表在了公众号上。这一月，浪狼的一月。 2017年5月：5月，我们赶了一个小尔迪和涛哥，马总。5月，我们金工实习，磨出属于自己的一个小锤子。5月，有很多一批人，总在凌晨的四点多相互叫着起床，一起吃封斋饭，封莱麦丹月份的斋。记得，一天都没拉下。电话里告诉我父母，说自己的儿子长大了。那些天，每晚的礼拜下，我都祈求着，给我们健康，幸福，知识和快乐，祈求给我们正道和坚忍！5月26日，我们的大四欢送会正式表演，而我和学长张明演出了其中一个节目相声。那天，第一次穿正装，一副老气横秋的大人模样。5月，是一群人的5月。 2017年6月：6月，注定是一个快乐与痛苦并存的6月吧。是一个美丽的季节，是一个难忘的季节，也是一个离别的季节。校园里除了一些燥热外，真的很漂亮。6月11日，和几位学长一起穿着学士服拍了很多照，定格了对他们来说再也回不去的风景。6月21日，是一个尊贵的夜晚，是盖德尔夜，那一晚，又有一群人，直到两点才睡下，做着有意义而有难忘的事情。那一晚，可以说是我内心最平静的一晚，再没有那样平静过了。6月22日，丢了手机，短短几天感觉和世界完全隔绝了一般，无法想象如今没有手机的生活。可能真会错过一个亿！6月28号，我们送走了大四最后几位毕业的学长学姐，可谓打心底里感慨时间流逝的飞快。那时，便告诉自己，一定要珍惜和善待身边的每一位兄弟姐妹，想着和他们在一起的时光将会是大学里最美的回忆。 2017年6月，也是我因为情感而情绪中的低谷。不眠的夜晚，期末考试的焦虑，压得我踹不过气来。喜欢一个女孩，问我为什么，我也说不出来。那时，每晚的心里话和小情绪都写在留言里。后来的后来，再回首，我也说不出来个一二三，喜欢就是喜欢。或许是因为太年轻吧。这一月，读了大冰的一部小说《好吗？好的》，记得在C楼和勇哥一起自习，他在准备期末考试，我却因为情感的低迷，无心学习，却在大冰的书中，找到了一个说不出来的世界。反正很美好吧。 2017年7月：正式进入期末备考阶段，每天都是打了鸡血学习吧。当身心全部都投入到某件事情上时，会发现，那真是一种幸福。7月15日，我大学的四分之一正式画上句号。大一第二学期结束了。 大学以来的第一个暑假，我选择了和学长们去另一个地方学习。这个暑假，真的过的是一个又有意义，又很仓促的的暑假。和学长们在那里认识到的人，学到的东西，还有给人印象和影响，真的深深地刻在了脑海里，感谢他们，感谢那二十几天。也在那二十天里，我才决定放下这一段熬人的感情，或许这是成长的一部分吧！ 2017年8月：我回了趟老家海原，去了趟银川，去了趟舅舅家，一个圈下来，便已匆匆忙忙来到了学校，提前了几天，只是为了参加一个Java培训。最开始的几天，感觉哇真好，还能免费培训，每天朝九晚五挤公交，中午便在那个培训地点的清真窗口上吃一顿，一种上班人的感受在心底已开始泛滥。后面的某一天，负责人把我叫去聊天，聊了很久。说到底，要交一万多元钱，保证可以怎样怎样，回来后，第二天再也没去，一觉睡到天荒！去你的小杰瑞，我哪儿有钱给你，自身难保呢~。8月31日，古尔邦节，在这边过的。一个繁忙的8月，仓促的8月。 2017年9月：又是9月，不在是单纯的别人的学弟学妹了，我们迎来了我们的学弟学妹。那一天，是我最累的一天，也是这次来西安后，做的第一件有意义的事情了。接了一整天的学弟学妹，记得接的第一个学弟是王金川，和父母提前一天过来。转了西安，游玩了古城。从图书馆出来的我和他相遇到图书馆和情人坑的那条街上，是田鸿才学长叫出去的。接的最后一个学弟是马伯谦，深夜十点了，下着毛毛细雨，在外面等他从航天城打的过来。接他回到我宿舍，安排好后，已不记得后续的事情了，或许已经睡着了。9月，还读了大冰的新书《我不》，依旧感觉很好。 2017年10月：这个十一，回家帮家人搬玉米，苦中作乐，乐在其中！10月21日，骑行去三星公园一起在秋天的落叶中，放松自我。10月24日，程序员的节日。10月25号，报名了西安城墙彩虹跑。十月，感觉很快的一个月。 2017年11月：11月，这个月，主打题是学长学姐的经验分享，那几天，有国创，有学长学姐分享完要做的微信推送。当我们三个把国创项目立项书交上去后的前一天晚上，第一次在C楼过夜，第一次睡到了桌子上，第二天清晨被发现，让我们下不为例。交上去的第二天，我便瘫痪了，身体累到不行，别人都说，怎么憔悴了不少…。其实，会发现，一件事情结果如何先不管，这个过程真的很难忘。这个月在微信公众号推送了好几篇，学长学姐们的经验也细细品读，希望自己在学习技术的路上少走些弯路。在自己搭建的博客上，我写下对自己的一句话：虽然有时候我走的很慢，但我相信自己可以走得很远！最后那几天，每天都固定在C楼一个教室，很充实。真心希望所有人的努力都会有相应的回报。 愿你有好运气，如果没有，愿你在不幸中学会慈悲。 愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。 感谢和我一直在一起的几位学长学姐一直的陪伴。 2017年12月：终于到了2017年，写到了12月，2017就这样被写到了结束。12月，考了四级，却把翻译内容写在了写作文的地方，被提前收走了，写到最后的翻译处才发现，自己写错了。考场的我在心里对自己笑了一万遍。那就来年再战吧！ 昨天晚上，组织了一次2017年末包饺子活动，感谢大二的这帮兄弟姐妹们。很感谢！忙了一天，理应睡的很香，但却失眠了。发表了2017年的倒数第二个微博，想对自己说一些话。 总之，2017年，生活和学习都在前进中，也在前进中，不断的成长，认识自己，认识这个世界。真的，成长了很多。 要想用一句话总结的话，我想那就是：问心无愧吧 2018年，希望自己在学习技术的道路上，可以更加的投入，逼自己一把。活成为自己想成为的模样。生活中，不再奢求谁可以陪伴你，聊天散步谈心情，发现每个人都有自己的生活轨迹，每个人都有自己的事情可做，终究要学会习惯一个人也可以活得很潇洒。总之，2018，希望我关心的和关心我的人，都能够幸福，快乐，充实吧，将自己活得更精致一些！ 你好2018！再见，再也不见，2017！ -----2017年12月30号晚 小虎|诉说17，规划18]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
