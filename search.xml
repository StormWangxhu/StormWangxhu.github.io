<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 基础]]></title>
    <url>%2F2018%2F12%2F04%2FJava%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、数据类型 包装类型 缓存池 二、String 概览 不可变的好处 String, StringBuffer and StringBuilder String Pool new String(“abc”) 三、运算 参数传递 float 与 double 隐式类型转换 switch 四、继承 访问权限 抽象类与接口 super 重写与重载 五、Object 通用方法 概览 equals() hashCode() toString() clone() 六、关键字 final static 七、反射 八、异常 九、泛型 十、注解 十一、特性 Java 各版本的新特性 Java 与 C++ 的区别 JRE or JDK 参考资料 一、数据类型包装类型八个基本类型： boolean/1 byte/8 char/16 short/16 int/32 float/32 long/64 double/64 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 二、String概览String 被声明为 final，因此它不可被继承。 内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 不可变的好处1. 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 Program Creek : Why String is immutable in Java? String, StringBuffer and StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String("aaa");String s2 = new String("aaa");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = "bbb";String s6 = "bbb";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 StackOverflow : What is String interning? 深入解析 String#intern new String(“abc”)使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 12345public class NewStringTest &#123; public static void main(String[] args) &#123; String s = new String("abc"); &#125;&#125; 使用 javap -verbose 进行反编译，得到以下内容： 123456789101112131415161718192021// ...Constant pool:// ... #2 = Class #18 // java/lang/String #3 = String #19 // abc// ... #18 = Utf8 java/lang/String #19 = Utf8 abc// ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V 9: astore_1// ... 在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。 以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 三、运算参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。 以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。 1234567891011121314151617181920public class Dog &#123; String name; Dog(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125; void setName(String name) &#123; this.name = name; &#125; String getObjectAddress() &#123; return super.toString(); &#125;&#125; 12345678910111213141516public class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog("A"); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A &#125; private static void func(Dog dog) &#123; System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog("B"); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B &#125;&#125; 如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。 1234567891011class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog("A"); func(dog); System.out.println(dog.getName()); // B &#125; private static void func(Dog dog) &#123; dog.setName("B"); &#125;&#125; StackOverflow: Is Java “pass-by-reference” or “pass-by-value”? float 与 doubleJava 不能隐式执行向下转型，因为这会使得精度降低。 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。 1// float f = 1.1; 1.1f 字面量才是 float 类型。 1float f = 1.1f; 隐式类型转换因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。 12short s1 = 1;// s1 = s1 + 1; 但是使用 += 或者 ++ 运算符可以执行隐式类型转换。 12s1 += 1;// s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型： 1s1 = (short) (s1 + 1); StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting? switch从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = "a";switch (s) &#123; case "a": System.out.println("aaa"); break; case "b": System.out.println("bbb"); break;&#125; switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。 123456789// long x = 111;// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'// case 111:// System.out.println(111);// break;// case 222:// System.out.println(222);// break;// &#125; StackOverflow : Why can’t your switch statement data type be long, Java? 四、继承访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。 可以对类或类中的成员（字段以及方法）加上访问修饰符。 类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 123456789101112public class AccessExample &#123; private int id; public String getId() &#123; return id + ""; &#125; public void setId(String id) &#123; this.id = Integer.valueOf(id); &#125;&#125; 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 12345678910111213141516public class AccessWithInnerClassExample &#123; private class InnerClass &#123; int x; &#125; private InnerClass innerClass; public AccessWithInnerClassExample() &#123; innerClass = new InnerClass(); &#125; public int getValue() &#123; return innerClass.x; // 直接访问 &#125;&#125; 抽象类与接口1. 抽象类 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。 1234567891011public abstract class AbstractClassExample &#123; protected int x; private int y; public abstract void func1(); public void func2() &#123; System.out.println("func2"); &#125;&#125; 123456public class AbstractExtendClassExample extends AbstractClassExample &#123; @Override public void func1() &#123; System.out.println("func1"); &#125;&#125; 123// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiatedAbstractClassExample ac2 = new AbstractExtendClassExample();ac2.func1(); 2. 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112131415public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println("func2"); &#125; int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here&#125; 123456public class InterfaceImplementExample implements InterfaceExample &#123; @Override public void func1() &#123; System.out.println("func1"); &#125;&#125; 1234// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x); 3. 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 4. 使用选择 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 深入理解 abstract class 和 interface When to Use Abstract Class and Interface super 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 1234567891011121314public class SuperExample &#123; protected int x; protected int y; public SuperExample(int x, int y) &#123; this.x = x; this.y = y; &#125; public void func() &#123; System.out.println("SuperExample.func()"); &#125;&#125; 123456789101112131415public class SuperExtendExample extends SuperExample &#123; private int z; public SuperExtendExample(int x, int y, int z) &#123; super(x, y); this.z = z; &#125; @Override public void func() &#123; super.func(); System.out.println("SuperExtendExample.func()"); &#125;&#125; 12SuperExample e = new SuperExtendExample(1, 2, 3);e.func(); 12SuperExample.func()SuperExtendExample.func() Using the Keyword super 重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有有以下两个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 五、Object 通用方法概览12345678910111213141516171819202122public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException equals()1. 等价关系 Ⅰ 自反性 1x.equals(x); // true Ⅱ 对称性 1x.equals(y) == y.equals(x); // true Ⅲ 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; Ⅳ 一致性 多次调用 equals() 方法结果不变 1x.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false 1x.equals(null); // false; 2. 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 123456789101112131415161718192021222324public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 12345678public class ToStringExample &#123; private int number; public ToStringExample(int number) &#123; this.number = number; &#125;&#125; 12ToStringExample example = new ToStringExample(123);System.out.println(example.toString()); 1ToStringExample@4554617c clone()1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 1234public class CloneExample &#123; private int a; private int b;&#125; 12CloneExample e1 = new CloneExample();// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' 重写 clone() 得到以下实现： 123456789public class CloneExample &#123; private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125; 123456CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 1java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 123456789101112131415161718192021222324public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125; 123456789ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 1234567891011121314151617181920212223242526272829public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125; 123456789DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 1234567891011121314151617181920212223242526public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125; 1234CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 六、关键字final1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2. 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 static1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块 静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println("123"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 1123 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = "静态变量"; 123static &#123; System.out.println("静态语句块");&#125; 1public String field = "实例变量"; 123&#123; System.out.println("普通语句块");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println("构造函数");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 七、反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 反射的优点： 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的API定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点： 尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 Trail: The Reflection API 深入解析 Java 反射（1）- 基础 八、异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种： 受检异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复； 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。 Java 入门之异常处理 Java 异常的面试问题及答案 -Part 1 九、泛型123456public class Box&lt;T&gt; &#123; // T stands for "Type" private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; Java 泛型详解 10 道 Java 泛型面试题 十、注解Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。 注解 Annotation 实现原理与自定义注解例子 十一、特性Java 各版本的新特性New highlights in Java SE 8 Lambda Expressions Pipelines and Streams Date and Time API Default Methods Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators Parallel operations PermGen Error Removed New highlights in Java SE 7 Strings in Switch Statement Type Inference for Generic Instance Creation Multiple Exception Handling Support for Dynamic Languages Try with Resources Java nio Package Binary Literals, Underscore in literals Diamond Syntax Difference between Java 1.8 and Java 1.7? Java 8 特性 Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。 What are the main differences between Java and C++? JRE or JDK JRE is the JVM program, Java application need to run on JRE. JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac” 参考资料 Eckel B. Java 编程思想[M]. 机械工业出版社, 2002. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 脑图大全]]></title>
    <url>%2F2018%2F09%2F27%2FJava-%E8%84%91%E5%9B%BE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前言这篇文章给出关于 Java 脑图总结 链接脑图大全]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java脑图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 后端常见面试问题总结大全]]></title>
    <url>%2F2018%2F09%2F27%2FJava-%E5%90%8E%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出一篇掘金上总结很好的一篇后端人员面试常见问题总结，我觉得非常棒！ 内容如下： 计算机网络常见面试题 Linux相关常见面试题 MySQL常见面试题 Redis Java 数据结构 算法 spring 链接Java 后端常见面试问题总结大全 下面再给出 Java集合 相关的链接 Java集合 总结 Set 集合 ConcurrentHashMap 基于 Jdk1.8 [源码解析] HashMap 总结 Map 集合、散列表、红黑树介绍 List 集合 TreeMap LinkedHashMap Collection 总览]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络常见面试题</tag>
        <tag>Linux相关常见面试题</tag>
        <tag>MySQL常见面试题</tag>
        <tag>Redis</tag>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>spring</tag>
        <tag>Map、List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库总结大全]]></title>
    <url>%2F2018%2F09%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出关于数据库MySQL的总结，很不错。 链接InnoDB记录存储结构InnoDB记录存储结构 InnoDB数据页结构InnoDB数据页结构 MySQL 命令执行过程和存储引擎概述MySQL 命令执行过程和存储引擎概述 MySQL 索引(上)MySQL索引(基础原理) MySQL 锁引(中)MySQL 锁引(索引优化) MySQL 的基本管理MySQL 的基本管理 MySQL 数据目录MySQL 数据目录 MySQL 概述MySQL 概述 MySQL 数据类型MySQL 数据类型 MySQL 表的基本操作(上)MySQL 表的基本操作(上) 数据库基本操作数据库基本操作(库的增删改查) 数据库表的基本操作(上)数据库表的基本操作(上) 数据库表的基本操作(下)数据库表的基本操作(下) 查询简介(一)查询简介(一) 查询简介(二)查询简介(二) 查询简介(三）表达式和函数查询简介(三）表达式和函数 查询简介(四) 类型转换和分组查询简介(四) 类型转换和分组 查询简介(五) 子查询查询简介(五) 子查询 查询简介(六) 连接查询查询简介(六) 连接查询 查询简介(七) 组合查询查询简介(七) 组合查询 数据的插入、删除、更新数据的插入、删除、更新 索引和锁终结版数据库两大神器[锁，索引] 数据库面试必看数据库面试必看]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL总结</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大基础排序总结]]></title>
    <url>%2F2018%2F09%2F27%2F%E5%85%AB%E5%A4%A7%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出八大基础排序的总结以及Java 实现。 链接八大基础排序总结]]></content>
      <categories>
        <category>算法数据结构</category>
      </categories>
      <tags>
        <tag>基础排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说几道简单算法题]]></title>
    <url>%2F2018%2F09%2F27%2F%E8%AF%B4%E5%87%A0%E9%81%93%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简答算法总结先给出八大排序的链接： 八大基础排序总结 链接 上面的理解后，下面给出常见简单算法题： 十道简单算法题(一) 十道简单算法题(二)]]></content>
      <categories>
        <category>算法数据结构</category>
      </categories>
      <tags>
        <tag>简单算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 总结]]></title>
    <url>%2F2018%2F09%2F27%2FSpring-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言本篇博客是关于框架Spring 的一些好的总结，给出链接以更好的学习。 链接Spring 入门第一篇 Spring [依赖注入] Spring [AOP模块] Spring [DAO模块] SpringMVC [开发Controller] SpringMVC [参数绑定、数据回显、文件上传] SpringMVC [校验器、统一处理异常、RESTful、拦截器] SpringBoot 入门 SpringData JPA 入门 Spring IOC 总结 Spring AOP总结 上面是关于Spring 的一些总结，非常棒。 脚踏实地，仰望星空！]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis 总结]]></title>
    <url>%2F2018%2F09%2F27%2FMyBatis-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言下面给出关于MyBatis 的总结。 链接MyBatis 入门 MyBatis [配置文件] MyBatis [关联映射] MyBatis [缓存、代理、逆向工程] MyBatis [与Spring 整合] MyBatis [面试题] 上面是关于MyBatis 的一些总结！ 仰望星空，脚踏实地！]]></content>
      <categories>
        <category>MyBatis总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试前需要了解的东西]]></title>
    <url>%2F2018%2F09%2F27%2F%E9%9D%A2%E8%AF%95%E5%89%8D%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[前言本篇博客给出别人整理出的一些面试常见题目，在大二下面试的过程中经常问到的一些，这篇博文总结的也非常棒，里面也有博主自己整理的好的资源的链接。 仰望星空，脚踏实地！ 链接1.0 面试前需要了解的东西 2.0 几道让你拿offer的面试题 3.0 基础面试题 上面三个链接都包含的信息量比较大，需要耐心读完，理解！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>集合题总结</tag>
        <tag>Servlet+Tomcat题总结</tag>
        <tag>JSP题总结</tag>
        <tag>JDBC题总结</tag>
        <tag>数据库题总结</tag>
        <tag>HTTP题总结</tag>
        <tag>XML+JSON题总结</tag>
        <tag>过滤器监听器</tag>
        <tag>AJAX题总结</tag>
        <tag>MyBatis题总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统总结]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言下面给出操作系统相关的总结 操作系统第一篇 [引论] 操作系统第二篇 [进程管理] 操作系统第三篇 [线程] 操作系统第四篇 [处理机调度] 操作系统第五篇 [死锁] 操作系统第六篇 [存储器管理] 操作系统第七篇 [设备管理] 以上便是关于操作系统的一些总结好的文章。我会在后面的学习中，自己再学习，之后再进行补充，形成自己的理解。 脚踏实地，仰望星空！]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入 URL 到页面加载发生了什么]]></title>
    <url>%2F2018%2F09%2F25%2F%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言从输入 URL 到页面加载发生了什么？面试过程中也问过，下面一篇是很不错的文章。 大致总结： DNS 解析 TCP三次握手建立连接 发送HTTP请求 服务器处理请求并返回响应报文 浏览器进行解析渲染 TCP四次挥手连接结束 链接从输入 URL 到页面加载发生了什么]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>计算机网络常见面试题</tag>
        <tag>HTTP</tag>
        <tag>TCP/UDP</tag>
        <tag>三次握手/四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 命令]]></title>
    <url>%2F2018%2F09%2F25%2F%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81-Linux-%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常见Linux命令目录切换命令 cd usr ：切换到usr目录下 cd..或者cd../：回退到上一级目录 cd /：切换到系统根目录下 cd ~：切换到用户主目录 cd -：切换到上一个所在目录 目录的操作命令（增删改查） mkdir 目录名称：增加目录 ls或者ll（ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息 find 目录 参数： 寻找目录（查） mv 目录名称 目录的新位置： 移动目录的位置—剪切（改） cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r代表递归拷贝 rm [-rf] 目录: 删除目录（删） 文件的操作命令（增删改查） touch 文件名称: 文件的创建（增） cat/more/less/tail 文件名称 :文件的查看（查） 123456789- cat：只能显示最后一屏内容- more：可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看- less:可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看- tail-10 ：查看文件的后10行，Ctrl+C结束注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 vim 文件： 修改文件的内容（改） vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤： 1vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入:wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。） rm -rf 文件： 删除文件（删） 同目录删除：熟记 rm -rf 文件 即可 压缩文件的操作命令（１）、Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件 其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 比如：加入test目录下有三个文件分别是 :aaa.txt bbb.txt ccc.txt,如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令： 1tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf test.tar.gz /test/ （２）、解压压缩包： 命令：tar [-xvf] 压缩文件 其中：x：代表解压 示例： 1231 将/test下的test.tar.gz解压到当前目录下可以使用命令：tar -xvf test.tar.gz2 将/test下的test.tar.gz解压到根目录/usr下: tar -xvf xxx.tar.gz -C /usr（- C代表指定解压的位置） 其他常用命令 pwd： 显示当前所在位置 grep 要搜索的字符串 要搜索的文件 –color： 搜索命令，–color代表高亮显示 ps -ef/ps aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程） 注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。 kill -9 进程的pid： 杀死进程（-9 表示强制终止。） 先用ps查找进程，然后用kill杀掉 网络通信命令 查看当前系统的网卡信息：ifconfig 查看与某台机器的连接情况：ping 查看当前系统的端口使用：netstat -an shutdown： shutdown -h now： 指定现在立即关机；shutdown +5 &quot;System will shutdown after 5 minutes&quot;:指定5分钟后关机，同时送出警告信息给登入 reboot： reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）。 Linux命令链接下面给出常见Linux 命令网址大全 Linux命令大全]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String StringBuffer StringBuilder 有什么区别]]></title>
    <url>%2F2018%2F09%2F24%2FString-StringBuffer-StringBuilder-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[int 和 Integer 有什么区别]]></title>
    <url>%2F2018%2F09%2F23%2Fint-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java 虽然号称是面向对象的语言，但是原始数据类型仍然是重要的组成元素，所以在面试中，经常考察原始数据类型和包装等Java 语言特性。 今天一起看看： int 和Integer 有什么区别？谈谈Integer 的值的缓存范围。 典型回答 int int 是我们常说的整形数字，是Java 的8个原始数据类型（boolean、byte、short、char、int、float、double、long）之一。Java 语言虽然号称一切都是对象，但是原始数据类型是例外。 Integer Integer 是int 对应的包装类，它有一个int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间的转换等。在Java5 中，引入了自动装箱和自动拆箱功能（boxing/unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。 Integer 缓存 关于Integer缓存，这设计到Java5 中另一个改进。构建Integer 对象的传统方式是直接调用构造器，直接new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范范围，因而，在Java5 中新增了静态工厂方法valueOf ，在调用它的时候会利用一个缓存机制，带来明显的性能改进。按照Javadoc 这个值默认缓存是[-128,127]之间。 考点分析今天的问题涵盖了Java 里两个基础要素：原始数据类型、包装类。谈到这里，就可以非常自然的拓展到自动装箱、自动拆箱机制，进而考察封装类的一些设计和实践。坦白说，理解基本原理和用法已经足够日常工作需求了，但是要落实到具体场景，还是有很多问题需要仔细思考才能确定的。 比如： Java 使用的不同阶段，编译阶段、运行时，自动装箱/自动拆箱是发生在什么阶段？ 静态工厂方法valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗? 为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？ 阅读过Integer 源码吗？分析一下类或者某些方法的设计要点。 知识拓展理解自动装箱、拆箱自动装箱实际上算是一种语法糖。 什么是语法糖？可以简单理解为Java 平台为我们自动进行了一些转换，保证不同的写法在运行时等价，它发生在编译阶段，也就是生成的字节码是一致的。 像前面提到的整数，javac 替我们自动把装箱转换为 Integer.valueOf() ,把拆箱替换为Integer.intValue() ，这似乎也顺序回答了另一个问题，既然调用的是Integer.valueOf ,自然能够得到缓存的好处了。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对比 Hashtable HashMap TreeMap 有什么不同]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%AF%B9%E6%AF%94-Hashtable-HashMap-TreeMap-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈 fianl finally finalize 有什么不同]]></title>
    <url>%2F2018%2F09%2F21%2F20180921-%E8%B0%88%E8%B0%88-fianl-finally-finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%2F</url>
    <content type="text"><![CDATA[1所谓博客，不过孤芳自赏 一道 Java经典的基础题目： 谈谈 fianl finally finalize 有什么不同 典型回答 final： final 可以用来修饰类、方法、变量，分别有不同的意思。 （1）、修饰类：修饰的class代表不可以继承拓展 （2）、修饰方法：修饰的方法不可以重写（override） （3）、修饰变量：修饰的变量是不可以被修改的 finally finally 是java 用来保证重点代码一定要被被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。 finalize finalize 是基础类 java.lang.Object 的一个方法，他的设计目的是保证对象在被垃圾收集前完成资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。 考点分析这是一道非常经典的 Java 基础问题，上面的回答主要是从语法和实践角度出发的，其实还有很多方面可以深入探讨，面试官还可以考察我们对性能、并发、对象生命周期或垃圾收集基本过程的方面的理解。 final推荐使用 final 关键词来明确表示我们代码的语义、逻辑意图，这已经证明在许多场景下是非常好的实践，比如： 我们可以选择将方法或者类声明为 final,这样就可以明确告诉别人，这些行为是不允许修改的。 在 Java 许多的类库中定义的源码，在 java.lang 包下的很多类，相当一部分都被声明为 final class ? 在第三方类库的一些基础类中同样如此，这样可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。 使用 final 修饰参数或者变量，也可以很清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有的方法参数、本地变量、成员变量声明为 final 。 final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用与保护只读数据 ，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的需要。 final 也许会有性能的好处，很多文章或者书籍中都介绍了可在特定场景中提高性能，比如，利用final 有助于JVM 将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能JVM （如HotSpot）判断内联未必依赖final 的提示，要相信JVM 还是非常智能的。类似的，final 字段对性能的硬影响，大部分情况下，并没有考虑的必要。 finally对于finally ，明确的知道怎么使用就足够。需要关闭的连接等资源，更推荐使用 Java7 中添加的 try-catch-resource语句，因为通常Java 能够很好的处理异常情况，编码量也要少很多。何乐而不为？ 另外我们要注意一些常被考到的 finally 问题（也比较偏门），至少需要了解以下。比如，下面的代码会输出什么？ 123456try&#123; //do something System.exit(1);&#125;finally&#123; System.out.println("Print from finally");&#125; 上面的finally 里面的代码可不会被执行哦，这是一个特例。 finalize对于finallize ，我们要明确它是不推荐使用的，业界实践一再证明他不是个好的办法，在Java 9 中，甚至明确将Object.finalize() 标记为 deprecated ！如果没有特别的原因，不要实现finalize() 方法，也不要指望利用它来进行资源回收。 为什么呢？简单说，你无法保证finalize() 什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。 通常来说，利用上面的提到的try-with-resource 或者try-finally 机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑Java 提供的Cleaner 机制或者其他的替代方法。接下来，我们介绍更多的设计考虑和实现细节。 知识拓展关于final注意：final 不是immutable! 前面介绍了final在实践中的好处，需要注意的是，final 并不等于immutable ，比如下面这段代码： 123456final List&lt;String&gt; strList = new ArrayList();strList.add("1");strList.add("2");strList.add("3");List&lt;String&gt; unmodifiableList = List.of("1","2");unmodifiableList.add("3"); //运行时会报错 final 只能约束strList 这个引用不可以被赋值，但是strList 对象行为不被 final 影响，添加元素等操作完全是正常的。如果我们真的希望对象本身是不变的，那么需要相应的类支持不可变的行为，在上面的例子中，List.of() 方法创建的本身就是不可变的List ，最后这句add（） 是会在运行期间抛出异常的。在Java9中Lis新特性中List.of() 源码： 123static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3) &#123; return new ImmutableCollections.ListN&lt;&gt;(e1, e2, e3);&#125; ImmutableCollections 的源码： 1234567ListN(E... input)&#123; E[] tmp = (E[])new Object[input.length]; for(int i =0;i&lt;input.length;i++)&#123; tmp[i] = Object.requireNonNull(input[i]); &#125; this.elements=tmp ;&#125; 在new Object(input.length) 中，已经将添加的长度定死了。 immutable 在很多场景中是非常棒的选择，某种意义上说，Java 语言目前并没有原生的不可变支持，如果要实现immutable 的类，我们需要做到： 将class自身声明为final ，这样别人就不能拓展绕过限制了。 将所有成员变量定义为private 和final ，并且不要实现setter 方法。 通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。 如果确实需要实现getter 方法，或者其他可能返回内部状态的方法，使用copy-on-write 原则，创建私有的copy 。 这些原则在并发编程实践中也经常被用到。关于setter 和getter 方法，很多人喜欢直接用IDE 一次全部生成，建议最好是需要时有需要时再实现。 关于finalizefinalize 真的那么不堪？ 前面简单介绍了finalize 是一种已经被业界证明了不好的实践，那么为什么会导致那些问题呢？ finalize 的执行是和垃圾收集关联在一起的，一旦实现了非空的finalize 方法，就会导致相应对象回收呈数量级上的变慢，有人专门做过benchmark ，大概是40~50倍的下降。 因为finalize 被设计成在对象收集前调用，这就意外着实现fianlize方法的对象是个“特殊公民”。JVM 要对它进行额外的处理。finalize 本质上成为快速回收的阻碍者，可能导致你的对象经过垃圾收集周期才会被回收。 实践中，因为finalize 拖慢垃圾收集，导致大量的对象堆积，也是一种导致OOM 的原因。 从另外一个角度，我们要确保回收资源就是因为资源是有限的，垃圾收集时间的不可预测，可能会极大的家具资源占用。这意外着对于消耗非常高频的资源，千万别指望着finalize 作为最后的“守门员”，况且他已经暴露了如此多的问题。所以，用完资源推荐显示释放，或者利用资源池尽量重用。 总结今天，我们从语法角度分析了final 、finally 、finalize ，并且从安全、性能、垃圾收集等方面逐步深入，探讨实践中的注意事项。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>面试常见题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于这里，三家寨的风土人情]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%85%B3%E4%BA%8E%E8%BF%99%E9%87%8C%EF%BC%8C%E4%B8%89%E5%AE%B6%E5%AF%A8%E7%9A%84%E9%A3%8E%E5%9C%9F%E4%BA%BA%E6%83%85%2F</url>
    <content type="text"><![CDATA[或许满怀着期待和憧憬，所以抵挡住了一天一夜的车程的疲惫。在昭通火车站下火车后，我们就被接着走了。因夜已深，大部分餐馆已经闭门歇业，只有拐角处的一家烧烤店在打扫着最后关门前的烧烤屋，阿訇和寺管叔叔请我们在此吃了一顿烧烤。随后我们四人便向目的地前进，送走了另外两位后，又载着我们来到了三家寨。或许是因为放下了高度紧绷的神经，坐上车便已睡意朦胧。 靠在搭档的肩膀上睡着了，不知不觉便已到了，让我们惊讶的是我们见到的住宿环境比我们想象的要好的多的多，床铺子都是新的，软软的很舒服。住宿是在教室里，教室里有11张桌子，其中一张是讲桌，能坐下40人左右。送走了阿訇，伴随着疲惫，我也很快进入了梦想。 晨礼下来后，又睡着了。起来已经是七点半了，问了一下阿訇，让我们上午先休息休息，下午再去家访进行招生。坐不住的我们，在奥雪和紫优还有其他小朋友的带领下出去在村子里转了转。 说起是村子，却也没住着几户人家。这里地形是靠山，村子的形成是在两座大山的缝隙里蜿蜒形成的，有一条硬化路，随着地形在不远的尽头也看不到头了。我们先是沿着路走了离寺不远的几十米，身边的小朋友告诉我，我们不能再往下走了，我问为什么，小朋友告诉我，再往下走就是汉族的村庄了。寺管大哥家是沿路最后一家，和不远处的汉族村子相距40几米的样子。遇到了寺管大哥，叫我们进去坐一坐，想着不给人家找麻烦了，就在路口我们聊了聊，寺管大哥告诉我，这里主要农作物就是土豆和玉米。田地也不是很多，全部在山坡上，“支离破碎”。每家的年轻劳动力基本都是出去外面打工了，只留下几间略显荒凉又有点破旧的房屋坐立在山坡上。 大哥在教门上是一个很有上进心和思想的人。以前这里的人们近乎达到了野蛮的状态，我当时并不明白这个野蛮是一种什么样的野蛮，后面大哥告诉我，以前村子里的人经常去隔壁村子闹事，那里的汉族都怀有了一种敌意和敬畏之心。但是后来改变了，那个村子里的人们开始说，你们村子里的那些人为什么这些年不见了。叔叔告诉我，这是因为真理来到了这个地方，自从1998年建立了这座清真寺后，这里的人们就开始慢慢改变了，他们知道了人生存在的意义，就是要劝人行善，止人作恶…。感赞，这里的人们得到了主的引领。 聊了一会儿我们便开始回去了，在回去的路上，看到了一位大叔在修双轮拉灰车，我过去说了一句赛俩目，他并没有给我回复，只是看着我笑了笑。屋子里出来了马关丹的妈妈，刚才那位是马关丹的爸爸。马关丹是一位脚上有残疾的女孩子，一直不说话，只是跟着我们一起在后面走着，后来阿訇家的女儿告诉我，她的脚是因为小时候上台阶的时候摔了，她妈妈没有给她看病，所以成了现在的样子，当时的我心里还在想这位妈妈好狠心呀。后来她妈妈从屋子里出来时，我说了一句赛俩目，她妈妈也回复了我。在交谈中，还是有语言障碍的，说的基本听不懂，只有根据话里的一些词去判断她说的是哪方面的内容。她们家的房子很破很破，因为这几天下雨的缘故，我都感觉快塌了。屋外也没有什么大面积的院子，只有一条从硬化路到家门口的一个小路，和家门口到山脚下牛棚里的一条路，有2头牛，还有一些鸡。聊着聊着，我才知道这个家庭的命运也多苦了，我无法得知她说的全部内容，但是她说着说着便开始哽咽，眼睛中有泪花在打转。她告诉我她有时候都不想再活着这个世上了，不知道还有什么要活得，我知道这个家庭很不幸，她已经承受了很多很多。 生了2个儿子，全部夭折了，一个女儿腿脚上还留下了残疾，丈夫他也给我说了，但是没有听懂，但是可以判定家长的劳动力几乎是他一个人。种着几亩田地，一年下来也才能收获2000元上下。只够养活这个家，她告诉我自己47岁了，但我从她的脸上却看到了60几岁老人的模样，俨然不像她说的那个年龄，但是女儿却也只有10岁。最后她说，感赞，我们都还活着。马关丹戴着头巾，一直默默的跟在我们的身后。 我听着内心很沉重，回到了寺里，师娘叫着吃饭呢。 下午做完pieshi，我们就在阿訇家子女的带领下去家访，其实也没有走几家，大多数家中都是老人，或者门早已紧闭，荒草丛生。 不一会儿我们便又采访回到了原点，师娘又叫我们吃饭。早晨都是沿着路超着山下坡方向去看了看，下午沿着山坡向上走去采访，这里的房屋大多数都是两种建筑，一种是土墙房子，没有窗口那种，感觉和窑洞一样，一种是二层平顶瓦房，之所以是二层平顶瓦房，我想是因为地理原因，这里平地面积少之又少，靠天吃饭，平顶可以把上面的水全部收集。 我们的旁边只有一家商店，标准的来讲，是小买铺，是陈奥雪家开的，下午她才告诉我，她们家也即将要搬走了，在城里已经租好了房子，她妈妈在城里可以买杂货，她在城里上学。之所以她告诉我这个消息，是因为我想买一些作业本和画画本，想让孩子们尝试每天写日记，问了一下奥雪说她们家也没有什么本子了。这里没有进城的公交，有的只是绵延的那条仅有的硬化路，和路旁边的马粪和牛粪，因为在半山腰耕地要用到牛和马。想刷个牙，却只拿了牙膏，想买都没有个去处，只好洗小净时多洗洗牙。 总有一些人，连我们习以为常的东西都是一种奢侈，不论什么。但是他们却各个善良热情，虽然也有生活的疲惫，但从内心里，爱也是人的一种天性。明天要开课了，不知道能来多少个像奥雪紫优这样懂事又可爱的孩子，但我们希望他们都能来。 原文链接]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>支教</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试后想对你说]]></title>
    <url>%2F2018%2F05%2F13%2F%E9%9D%A2%E8%AF%95%E5%90%8E%E6%83%B3%E5%AF%B9%E4%BD%A0%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[前序开始时，抱着一颗暑期找实习的心态开始在实习僧和拉勾网上疯狂的投简历，投了很多很多。起初，会因为自己的简历状态是投递成功或者已被查看而欣喜不已。之后，就是一边心里乱激动一边又焦急的等待面试的邀请。效率最高的当为今日头条的效率，投了一天就打来电话确定面试时间和方式。其他的后面好像就石沉大海了，在拉勾网和实习僧上大多数简历状态最终的归宿就是以时间不合适或者经验不合适的标签落入了人家的人才库。不知道各个公司的人才库里装了多少像我这样的人。有些事情总有一个第一次，我的第一次面试就是今日头条，是视频面试，面试前的那一点点小小的紧张很微妙。后面，随着时间的推移，那些紧张也不翼而飞了，但是依旧会因为看到简历筛选和打来面试预约电话而内心小激动，想象一下，一头可爱的小鹿在心间直撞，停不下来的~那种心动的感觉。 后面的时候，依旧投了很多简历，后续收到了阿里、百度、携程等大小公司的或电话面，或视频面，或现场面的邀请。或许面试的形式也就无非这三种吧，没错，我都经历过了。有的一面，有的走到了二面，很不幸，没有走到三面的。要是能走到三面，实习offer也就基本到手了吧。 在找实习的这段时间里，也有非常大的收获，除了面试不会再紧张，还有很多面试时的提问，知识点的考察等的掌握。以前看书时，看了很多遍，但依旧可能不会在脑海中刻下。但是经历过第一次面试之后，一面会考什么，一个大体的范围就确定了，再在牛客网上多看看那些帖子和面经，就会发现，大部分公司的一面无非也就是那些东西了，所以下来后再看那些知识点的确理解的更透彻了，也掌握了，实践是检验真理的唯一标准。每一次的面试完后都会把面试完的知识点写下来，刚开始的时候，会发现，面试电话刚挂后，刚才面试了个啥，已经忘了，好快哟。后面就长经验了，要是电话面试，接电话的前一秒就是把录音开启，然后再就让他面吧，不要虚。下来之后，还可以听听自己的声音（嗯~声音也蛮好听的hhh），问题回答的怎么样，都可以事后慢慢总结这场面试过程回答问题的思路和一些表达方式上的不足。再总结，下次电话面试就会注意这些点了。一步一步，你会发现你在面试上的成长。因为在经历了华为的现场面时，我体会到了自己的成长。关于华为这儿，我后面再说，这开启了我倒霉又有收获的一天。 关于面试关于面试，在技术上，一面会考察很基础的知识，我起初时以为自己掌握了那些知识，但是头条面试完后，发现自己那是一种自我陶醉。陶醉在自己的世界里，有些知识就是停留在知道他是干什么的层面上。这时候，就会激发你知其然和知其所以然的渴望了，我要把他弄懂！ 一面后发现自己：哇，好菜呀~真的太菜了！没错，我的自信心被打击到了。所以，一边自我悲伤，一边快速逃离悲伤，还要一边继续把他搞定！这样的打击后，才会沉下心去。其实，生活中要得有那么点的打击，这样才能让自己认识到自己还活着，还有情绪的喜怒哀乐。关于打击，我想我受的足够多了，我身边的大佬太多了，也太强了！鲁迅先生说，世界上本没有路，走的人多了，也就有了路。打击也是一样：第一次打击的时候，你很悲伤，打击的多了，也就习以为常了！慢慢的，也就不去理会打击的感觉了，唯有好好学习去弥补就是了。 其他的面试我也总结过，这儿就不说了。这儿想说一下昨天的华为现场面试： 华为西安研究所 华为的现场总共两次，一面和二面都在一起，要是二面过了，好像就可以拿到口头实习offer了。在等待被叫面试的时间段里，发现自己身边的人大多数是大三的和研究生的，很多人一面几分钟就结束了，也有很多人被面试了好长时间。我就是那个被面试了好长时间的人。 他看了看我的简历，首先肯定是自我介绍了，我自己介绍了一下自己，说自己现在大二。他也很惊讶，大二就出来了。简历上写的东西为啥别人的都会问到会的，我就被问到项目了。我心里想，叔，你就问我点基础呗，我给你说一说。项目我才开始做，就知道怎么用呀，你能让我给你说啥！好巧的是，他就不问基础，问我框架方面的原理，还有很多…。具体的我就不说了，但是到最后，他就給我说大学生活和工作经验，告诉我，大学里是试错成本最低的时候，也是青春里最好的时光。有些错，当走上社会的时候，成本太高了，他说，欠下的东西，终究是要还的…告诉我不要太着急。聊了很久，给了我一些建议…。 感受之后，我也采纳了他的建议，走出门后，感觉一下子心情舒畅了很多。找实习先告一段落了。再说了，自己内心中真正呼唤自己的并不是把大学里为数不多的暑假在大二结束先祭奠了社会。内心中真正想要的是自己不一样的大学生活和经历，是日后可以回忆起来即感动又温馨的记忆，比如去支教一次等等。 实习的时间等到大三再祭奠社会吧。那时，我或许会成长的刚刚好，而我心怡的公司也刚好发现了我。这种东西就像有些人口中拿感情说事的话：感情这东西，谁说的上，或许上一秒擦肩而过，下一秒就一见钟情了呢。我想：未来这东西，定不会辜负你的努力的，或许上一次我还需沉淀，或许下一次，我就可以实现自己。唯有时间会告诉我答案~！ 所以，世界上没有白读的书，每一本都算数。也没有白走的经历，每一次都有收获。大二的我经历了这些面试后，虽然没有拿到最初抱着试试心态的实习offer。但是这些面试经历和面试官的交谈给了我自己知道的很多东西。 路，得自己选择，也得自己走。怎么走，也只有自己能决定，回顾至今大学的生活，我觉得自己确实被引导着，每一个寒假和暑假都过的很难忘和幸福，每一段在校时间也过的很丰富，但难免会有不一样的一段经历使你跌入低谷，但也会发现是那段低谷成就了现在坚强的你。遇到了很多有趣优秀的人，也做了一些记忆深刻对现在的我有这深深影响的事儿，（知感）。所以，别人的优秀你只能拿来做榜样，但不能效仿走一样的路。那样会发现自己过的很累很累。 毕业季14级毕业欢送会 所以，值此毕业季，我告诉自己：他们的今天的离开也就是你明天的离开，但幸运的是我还有时间，还有机会可以选择自己的路，可以做自己的喜欢做的事儿，可以亲自绘画属于自己的不一样的人生蓝图和明天。 最后应该告诫自己，也该告诫我的小伙伴们： “以时光盟誓，一切人确是在亏折之中。唯信道而且行善，并以真理相劝，以坚忍相勉的人则不然。” 坚忍行善 只愿这些即将毕业的学长学姐们，愿你们走遍天涯归来仍少年。也愿不管遇到什么困难，相信allah与我们同在！更希望年轻的我们抓住时间，别做语言上的巨人，行动上的矮子。 关于母亲节做杜瓦 或许你我都是这个世界中最平凡的人，但是我们都拥有世界上最不平凡的父爱和母爱。不论走到哪里，父母的心或许总是都在我们子女的身上。所以，不要仅仅是在母亲节或者父亲节上的某一天去表达我们的爱，而是常常的给他们多打几个电话，报一声健康和平安。在我们没有经济能力去报答的时候，请将我们的祝福放在我们的堵哇伊里。有经济能力的时候，更要如此！ 结尾本想着，写一写昨天自己的遇到的事儿，谁想，写着写着写到这里来了，说了这些。可以看到我的标签是要写自己自行车被别人骑走了，我和学长体验《唐人街探案》的激动人心的时刻，还有自己昨天坐车坐过站点很多站的荒凉。自行车丢的前一天，我的书在C楼也不见了，想表达一下自己对那些不自觉人的强烈不满。感觉自己花费时间去查监控，到头来自行车还找到了，也那么解决了，那我的那些精神损失需不需要费用呀？！！！ 但是，话又说回来，我俩个借此机会体验了一把什么叫做：校园无死角的视觉既视感！！！（校园里真的无死角） 所以，我把大冰《我不》书里的一句话写到这里，以此勉励： “星光不问赶路人，时光不负有心人。”也愿即将离去和后面将要离去的校园人阳光下活的像个小孩，风雨里像个大人。 你好，明天 你好，明天 你好，明天！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记百度 Java 实习第二面]]></title>
    <url>%2F2018%2F04%2F18%2F%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言突如其来哦，毫无防备…… 面试内容1、HashMap的存储结构 2、HashMap扩容过程旧数据如何处理？位置还是原来位置吗？ 3、HashMap对key有什么要求吗？一般用String作为key，问我能否用int或者其他Object类型 4、Object作为HashMap的key的话，对Object有什么要求吗？ 5、Object若不重写hashCode()的话，hashCode()如何计算出来的？ 6、hashCode()和equals()方法有什么联系？ 7、若对一个类不重写，它的equals()方法是如何比较的？（==比较） 8、==比较的是什么？ 9、hashCode()和equals()方法有什么要求吗？ 10、简单算法题：将一个二维数组顺时针旋转90度，说一下思路。 11、简单算法题：将一个int类型数字、负数逆序输出，须返回一个int类型数字。即反转 12、String能继承吗？就说到了用final修饰 13、final怎么用？分别说了修饰变量、方法、类 14、ConcurrentHashMap的分段锁原理 15、Java中有几种方式启动一个线程？（说了个start()、线程池不知道对否） 16、线程池有什么好处？ 17、Java中有几种线程池？ 18、TCP的三次握手 19、TCP如何保证可靠传输？ 20、框架用过哪些？说刚入门Spring、经典三层MVC 21、项目 22、Servlet是线程安全的吗？不安全 后记完了就说，嗯好了解了，那我们今天先到这里。加油]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记百度 Java 实习第一面]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言几天前，百度方面就打来了电话，和我确定了面试时间，没错，就是今天下午二点。我一点半就午休起来等待电话铃声的响起，过了两点后，还没有来，我的内心更慌了，过了十分后铃声突然响起，响了几秒钟就接了，哈哈。 面试内容这次把面试的主要内容简单介一下，有些问题回答的不太好，需要再仔细琢磨，主要内容如下： 1、简单自我介绍，（西电大二，自学Java，想找实习，balabala）….. 2、简要介绍简历上项目：网上图书商城，主要功能有哪些？用到哪些技术栈？说到了经典MVC三层框架，简单介绍 3、看我正在学习Spring，让简要说一下spring Ioc 4、问我是否用过spring+springMVC？ 5、有没有学过数据结构——&gt;引出数组和链表的区别？说到了数组和链表增删速度以及为什么？ 6、给了我10亿条散乱、无序的数据，让我找出1000个最大的数，问我有什么想法吗？（傻傻的说到了排序，递归，面试官自言到：用递归吗？凉了。。。一看我胡说，就再没有问） 7、Java 递归栈最深能递归多少次（说10个数据的话，递归肯定会溢出。这个我，没说上） 8、排序（和10亿数据有关，没回答上，让我下去了解一下） 9、JVM内存区域、类加载过程 10、类卸载发生到什么时候？ 11、JVM 垃圾对象回收相关（引用计数法、可达性分析算法判断对象死活；常用垃圾回收算法G1(JDK1.7以上)） 12、垃圾回收算法（标记清除，标记整理，复制算法） 13、什么时候会触发新生代、老年代垃圾回收？ 14、Java 内存模型 15、锁机制：volatile（内存可见性、禁止指令重排序），sychronized（monitorenter和monitorexit）在内存方面进行解释。同一时间，两个线程访问一个被sychronized修饰的方法块，JVM是如何阻止另外一个线程访问的？（面试官说回答的差不多） 16、数据库索引，索引如何做到快速查询？（不了解） 17、HTTP协议：问到后端给前端传递一条数据，HTTP是如何进行传递的？消息体里有哪些？后端传递的数据放在了HTTP哪里？（消息体这儿答得不太好，即数据内容怎么存放的？） 18、问我大一时参加的星火杯是什么？ 19、问我有没有什么展示我代码功底的：说到了Github 20、面试官问我有什么要问她的？（对，面试官是小姐姐诶），问了部门业务——大数据，部门人数—1000到2000 21、问我什么时候能去实习？ 后记然后就完了，对，完了。面试官说今天就聊这儿吧。所以还会有明天吗？挂了之后就想起来怎么没有问会有面试结果通知吗，嘎嘎嘎嘎嘎嘎。。。 总体感觉回答的还可以，也有答得不好的地方，要去努力了！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记阿里巴巴 Java 实习第一面]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%B0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言炎热的下午，刚在体育课上测完了一千米，嗓子要着火了，跑完后感觉要膨胀了，又测了50、身高、肺活量、体前屈。测完后就在树荫下休息，离下课还有10分钟的时候，口袋里的手机突然想起，拿起一看，阿里巴巴集团，当时就意识到可能是要和我商量面试时间，但接了后，却和其他公司不一样，面试官直接就问我，有时间吗？我们简单面试一下。我看了看体育老师，过去请了个假，就赶紧去一边面试了，不知道为什么声音很小，我有点儿听不清，好几次就请求面试官：“不好意思呢，刚才没听清，嘻嘻~”挺尴尬的。面试了34分钟。我到现在有的问题都忘了，大体内容如下： 面试内容1、自我介绍：balabala 2、现在都学习了些什么？balabala 3、HashMap底层实现原理，是否读过HashMap源码？ 4、HashMap和ConcurrentHashMap在线程安全上有何区别？如何实现？ 5、项目：小程序。问到遇到什么问题吗？在这里问了好多，还有业务逻辑，感觉答得都不是太好。 6、了解过哪些中间件？ 7、Java 的特性？ 8、Java 内存模型 9、JVM 类加载机制 10、双亲委派模型 11、Object都有哪些方法？ 12、高并发、高并发、高并发！重要的说三遍。如何解决？答得不太好，一脸懵逼！ 13、锁优化CAS 14、sychronized和volitile 15、反射的使用场景？很重要，我没怎么说上来。下来后回想感觉应该和框架（Spring）还有关系,以后学习得注意点。 16、还问了我的英语怎么样？考六级了吗 17、在Github上关注了什么开源项目了没？ 18、看了我的博客（挺开心的，感觉博客搭建上还是挺好的），问我是自学吗？一般怎么学？ 19、了解Linux吗？确实没咋用，就说了知道几个命令。 20、觉得自己是一个怎样的人？ 21、又想起来了，还问到了异常？并解释为什么？ 大概就这些吧，有些记不起来了，最后也没像头条面试官一样，问我有什么问题要问吗？就说那就今天先面试到这儿，我说了声谢谢。哦，对了，开头自我介绍前，还问我什么时候可以来实习，能实习多长时间？然后就没了，大厂面试就这样结束了。不知道结果会怎么样，以我现在的知识，估计也去不了，还得继续加油努力呢！路漫漫其修远兮，吾将上下而求索！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再看 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%86%8D%E7%9C%8B-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[所谓博客，不过孤芳自赏 前言在这篇中，我们再谈 JVM 的编译常量、ClassLoader 、和系统类加载器。通过代码实例来理解掌握三者的奥秘。请带上你的好奇心哦~ 编译常量和变量与初始化关于static和final变量对类的初始化到底有什么影响，他们的使用也是面试中经常的考点。首先来看一道程序：1234567891011121314package stormwangxhu.example;class FianlTest&#123; //x是一个编译时常量 public static final int x =6/3; static &#123; System.out.println("FinalTest static block"); &#125;&#125;public class StaticAndFinalTest &#123; public static void main(String[] args) &#123; System.out.println(FianlTest.x);// x=2。static代码块没有执行。 &#125;&#125; 123456789101112131415161718package stormwangxhu.example;import java.util.Random;class FianlTest2&#123; //注意此处，x是编译时变量，即在运行时才能确定x的值。 public static final int x = new Random().nextInt(100);//产生一个0到99的随机数 static &#123; System.out.println("FinalTest2 static block"); &#125;&#125;public class StaticAndFianlTest2 &#123; public static void main(String[] args) &#123; System.out.println(FianlTest2.x); //FinalTest2 static block 先执行static代码块 //43(每次执行不一样) 后执行编译变量 &#125;&#125; 那么，程序的输出是不是出乎你的意料呢，当static和final 修饰的是一个编译时常量时，那么其在初始化阶段就已经确定。所以其初始化将按顺序进行初始化。而对于编译时变量，在初始化阶段并不能确定其具体的值，所以初始化阶段会先初始化类变量，再在程序运行期间进行编译变量的执行。 再看类初始化初始化子类在第一篇博文中我很清楚自己这样写道：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。那么对于这句话我们来看一个实例： 123456789101112131415161718192021222324package stormwangxhu.example;class Parent&#123; static int a =3 ; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println(Child.b); &#125;&#125; 那么这道题的答案是多少呢？若你理解了那句话，答案会很快知晓： 1234StaticTest1 static blockParent static blockChild static block4 还有，当一个类的父类被同一个加载器加载过后，便不会再去加载这个类。 1234567891011121314151617181920212223242526package stormwangxhu.example;class Parent&#123; static int a =3 ; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println("-----------------------------------------"); System.out.println(Parent.a); System.out.println(Child.b); &#125;&#125; 那么，这样又会输出什么呢？ 123456StaticTest1 static block-----------------------------------------Parent static block3Child static block4 为什么会输出这样呢？因为同一个类加载器对加载过的父类若已经加载过，则不再进行加载。但是若是两个不同的类加载器则依旧会执行。 因此我们得出结论：程序中对子类的主动使用，会导致父类被初始化；但对父类的主动使用并不会导致子类初始化。一个最简单明了的例子就是：不可能说生成一个Object 对象就导致系统中所有子类都会被初始化。 再谈类的主动使用首先我们说明结论：只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。 什么意思呢？我们来看代码： 12345678910111213141516171819202122232425262728293031package stormwangxhu.example;class Parent&#123; //静态变量 static int a =3 ; static &#123; System.out.println("Parent static block"); &#125; //静态方法 static void doSomething()&#123; System.out.println("do something"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println(Child.a); Child.doSomething(); &#125;&#125; 来看结果： 1234StaticTest1 static blockParent static block3do something 从结果可以看出，根本就没执行Child ，也就意外根本没有初始化。我们再来理解给出的结论，类变量a 它是在类中定义的，静态方法doSometing() 也是在父类中定义的，所以用子类打印出a 的值，就不是对子类的一个主动使用，而是对父类的一个主动使用。 再谈类加载ClassLoader结论：调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 1234567891011121314151617181920package stormwangxhu.example;class CL&#123; static &#123; System.out.println("Class CL"); &#125;&#125;public class ClassLoaderTest1 &#123; public static void main(String[] args) &#123; ClassLoader classLoader=ClassLoader.getSystemClassLoader(); try &#123; Class&lt;?&gt; clazz=classLoader.loadClass("stormwangxhu.example.CL");//不会导致初始化 System.out.println("------------------------------------"); clazz=Class.forName("stormwangxhu.example.CL");//反射，会导致类的初始化 &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 再看结果： 12------------------------------------Class CL 也就是主动使用除了6种情况下会导致类的主动使用而被初始化，其他的都不会导致类的初始化。 深解双亲委托机制 根类加载器该加载器无父类加载器，实现依赖于底层操作系统，属于虚拟机的一部分，并没有继承java.lang.ClassLoader 。负责加载虚拟机的核心类库，如java.lang.*等。 拓展类加载器加载拓展API 系统类加载器加载CLASSPATH路径下定义的Class。 ClassLoader加载流程所以一个程序启动时，是怎么加载的呢？我们一起来看看： 当运行一个Java程序的时候，JVM 启动，运行启动类加载器，该加载器（ClassLoader）加载核心的API（拓展类加载器和系统类加载器也在此时被加载），然后调用拓展类加载器加载拓展API，最后系统类加载器加载CLASSPATH目录下定义的Class。以上就是一个程序最基本的加载流程。 再看代码： 12345678910111213141516171819202122protected synchronized Class loadClass(String name ,boolean resolve)&#123; //首先检查该name指定的class是否被加载 Class c=findLoadedClass(name); if (c==null)&#123;//c为空，说明该类没有被加载过 try &#123; if (parent!=null)&#123; //若parent不为null，则调用parent的loadClass进行加载 c=parent.laodClass(name,false); &#125;else &#123; //parent为null，则调用启动类加载器进行加载 c=findBootstarpClass0(name); &#125; &#125;catch (ClassNotFoundException e)&#123; //若仍然无法加载成功，则调用自身的findClass进行加载 c=findClass(name); &#125; &#125; if (resolve)&#123; resolveClass(c); &#125; return c; &#125; 以上可以看出一个类的加载使用了双亲委托模式。 为什么要使用双亲委托模型我们为什么要使用双亲委托模型呢？记得阿里第一面就问我，我当时表达不出来。 原因一：可以避免重复加载，当父类已经加载了该类的时候，就没有必要子ClassLoader 再加载一次 原因二：考虑到安全因素，若不使用这种委托模式，那么可以随时用自定义得String 来动态替代Java核心API 中定义的类型，这样会存在非常大的隐患，而父类委托的方式就可以避免这种情况，因为String 已经在启动时被加载，所以， 用户自定义是无法加载一个自定义的ClassLoader ClassLoader一些重要方法loadClass方法ClassLoader.loadClass() 是ClassLoader 的入口点。定义如下： 1Class loadClass(String name,boolean resolve); 1、name 是JVM需要的类的名称，如：java.lang.Object 。 2、resolve 参数告诉方法是否需要解析类。在准备执行该类前，应该考虑解析。注意：并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那就不需要解析。 findClass方法loadClass 默认实现调用这个新方法。findClass的用途包含ClassLoader 的所有特殊代码，而不须复制其他代码（例如：当专门的方法失败时，调用系统的ClassLoader） 目的是：从本地文件系统使用实现的类加载器加载一个类。为了创建自己的类加载器，应该拓展ClassLoader类，这是一个抽象类。可以创建一个FileClassLoader extends ClassLoader，然后覆盖ClassLoader中的findClass(String name)方法，这个方法通过类名得到一个Class对象。 1234public Class findClass()&#123; byte[] date =loadClassData(name); return defineClass(name,data,0,data.length);&#125; defineClass方法defineClass方法接受由原始字节组成的数组，并把它转换成Class对象。原始数组包含从文件系统或网络装入的数据。defineClass管理JVM的许多复杂的实现层面——它把字节码分析成运行时数据结构。检验有效行等。因为defineClass方法被标记为final，所以不能覆盖它。 forName方法Class类中有一个静态方forName，这个方法和ClassLoader中的loadClass方法目的一样，都是用来加载class的，但是两者在作用上有所区别。 先来看看看forName()方法： 1Class clazz = Class.forName("something"); 或者： 12ClassLoader c1 =Thread.currentThread().getContextClassLoader();Class clazz= c1.loadClass("something"); Class.forName()调用Class.forName(name,initialize,loader); 也就是Class.forName(&quot;something&quot;) 等同于Class.forName(&quot;something&quot;,true,CALLCLASS.class.getClassLoader()); 。 解释： 第二个参数”true”，用于设置加载类时是否连接该类，即加载中的连接阶段，true就连接，否则就不连接。 再看看loadClass()方法： loadClass方法定义是protected，也就是说，该方法是被保护的，而用户使用的方法是一个参数，一个参数的loadClass方法实际上就时调用了两个参数，第二个参数默认是false。因此，在这里可以看出通过loadClass加载类实际上就是加载的时候并不对该类解析 因此不会初始化该类。而Class的forName方法则相反，使用forName加载的时候就会将Class进行解析和初始化。 你知道JVM 使用什么字符吗？答案是：Unicode characters java开发者必须牢记：在java中字符只以一种形式存在，那就是Unicode（不选则任何特定的编码，直接使用它们在字符集中的编号，这就是统一的唯一的方式）。 那么“在java中”到底是指哪里呢？是指在JVM中、在内存中、在我们写的代码里声明的每一个char、String类型的变量中。 JVM 这种的约定使得一个字符分为两部分：JVM 内部和OS 的文件系统。在JVM 内部，统一使用Unicode表示，当这个字符被从JVM 内部移动到外部（即保存为文件系统中的一个文件内容时），就进行了编码转换，使用了具体的编码方案。因此可以说，所有的编码转换只发生在边界的地方，JVM 和 OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。 Windows中默认字符是GBK，在面向字符流时，Reader和Writer只会使用这个默认的编码来转换，而不能为一个Reader和Writer指定转换时使用的编码。这意外着，若使用中文版Windows系统，其中存放了一个UTF-8编码的文件，当采用Reader类读入的时候，他还会使用GBK来转换，转换后内容当然不对！所以在需要GBK以外的编码时，就必须采用编码转换：一个字符与字节之间的转换。因此I/O系统中能够指定转换编码的地方，也就是字符和字节转换的地方。那就是InputStreamReader 和OutputStreamWriter。这两个类是字节流和字符流之间的适配器，他们承担着编码转换的地方。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 JVM 垃圾收集器和内存分配策略]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%88%9D%E6%8E%A2-JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[所谓博客，不过孤芳自赏 前言 Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。 本篇博文主要输出JVM的常见垃圾回收算法（也就是面试官长问到的GC），以及在 JVM 虚拟机中，JVM 是如何判断对象的有效性、对象在内存中是按照什么规则存放的，请带上你的好奇心慢慢往下读。 在JVM内存区域中，属于线程私有的程序计数器、虚拟机栈和本地方法栈这个3个区域随着线程而生而死。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。每一个栈帧要分配多少内存基本在类结构基本确定下来时已经确定。因此这几个区域的内存分配和回收都具有确定性，无需过多考虑回收问题，因为方法或者线程结束时，内存自然就跟着回收了。 其实，我们关心的是JVM 中的线程共享数据区：Java 堆和方法区。这部分的内存分配和回收都是动态的，而垃圾收集器所关注的就是这部分内存。那么在这两个区域中，JVM 是如何进行内存分配和回收的呢？我也很好奇~。 我们先看堆中，再看方法区！ 我们知道，在Java堆中，存放着Java世界几乎所有的对象实例，垃圾回收器在对堆进行回收之前，第一件事情就是需要知道这些对象“死”还是“活”着，如何知道，JVM 使用引用计数法、可达性分析算法进行判断。 看”堆”中判断对象生死法宝首先，无论是现在要说的引用计数算法，还是后文的可达性分析算法，都和对象的引用有关，该算法的目标对象就是引用。说该算法前，就不得不说引用了。 再谈引用其实，判定对象的存活都与引用有关，在Jdk 1.2 之后，Java对引用扩充如下：分位强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这4种引用强度依次逐渐减弱。 强引用：程序代码中普遍存在的引用，只要该引用存在，垃圾收集器永远不会回收掉被引用的对象。 1Object obj=new Object(); 软引用：描述有用但非必需的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。 弱引用：是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 引用计数算法什么是引用计数法？很多人这样说到：每一个对象中都添加一个引用计数器，当该引用被一个地方引用一次，就+1；引用失效时，就-1。当计数器为0时，说明该对象不可能再被使用。 客观说，引用计数算法，实现简单、效率高，大部分情况下很不错，如微软COM技术等在应用。但Java虚拟机里却没有选用该算法，最主要原因是：很难解决对象之间相互循环引用问题。即两个引用引用着对方的实例对象。 可达性分析算法主流程序语言：Java、C# 都使用可达性分析算法来判断对象是否存活。这就很牛逼了，到底是什么样的算法，竟然被Java用来判断对象是否存活了。 可达性分析算法基本思路：通过一系列的称为GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 （Reference Chain）,当一个对象到GC Roots 没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的； 从下图来看：对象object5,6,7虽然相互关联，但是他们到GC Roots是不可达的，所以它们将会被判定为是可回收对象。 那么，可作为GC Roots对象有哪些？一般从栈和方法区去思考： 栈： 虚拟机栈（栈帧中的本地变量表）中引用对象。 本地方法栈中JNI（一般来说的Native方法）引用的对象。 方法区： 类静态属性引用的对象。 常量引用的对象。 再来对比看一下，熟记他们。下图所示： 以上就是堆中关于JVM判断对象是否存活的两个算法，和我说一遍：引用计数算法——可达性分析算法。 再看”方法区”垃圾收集方法区中垃圾回收对象主要为两个：废弃常量和无用的类。 废弃常量与堆中回收对象非常类似（简单）。但判断是否无用类即比较苛刻。 判定一个类是否是无用的类条件相对苛刻： 该类所有实例都已被回收，即Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。 在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此； 常见GC算法你了解吗垃圾收集算法实现设计大量细节，各个平台操作虚拟机内存方法不一样，所以只说算法思想。 标记-清除 算法如同其名字一样，该算法（最基础收集算法）分两步：标记——&gt;清除。 标记：标记的是什么？其实标记的是所有需要回收对象。 清除：清除什么？清除上一步被标记的需要回收对象。 从上图可以看出：被标记的对象被清除了。但也发现了两个不足：效率问题、空间问题。 效率问题：标记、清除连个过程效率都不高。 空间问题：清除后产生大量不连续内存碎片。如若分配较大对象时，则无法找到足够连续内存而不得不提前触发另外一次垃圾回收动作。 复制 算法为了解决 标记-清除 算法带来的效率问题，复制算法应用而生。 算法思想：将可用内存按容量划分为大小相等两块，每次只使用其中一块。 复制：复制什么？一块内存用完后，复制其中存活对象到另一块。复制存活~复制存活~复制存活~ 优点：每次对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效； 不足：提高效率的代价是将内存缩小到原来的一半。 现代商业虚拟机都采用这种收集算法来回收新生代。HotSpot虚拟机将内存划分为Eden 和2个Survivor 空间，比例8:1:1。每次只是用Eden 和一个Survivor 空间。回收时，将Eden 和Survivor 中还存活对象复制到另外一块Survivor 空间中。当Survivor 空间不足时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion），让对象进入老年代。分配担保机制后文中会说到。 标记-整理 算法标记整理算法，也是一样，分2个过程。标记——整理 标记：标记什么？标记需要被回收对象。 整理：此处不像清除，将其清除掉，而是让所有存活对象都向一端移动，然后清理掉端边界以外内存。 所以，标记清除算法和标记整理算法可以比较吗？试试： 分代收集 算法分代收集算法并没有什么心思想，只是根据对向存活周期不同，将内存划分为几块。一般讲 Java 堆分为新生代和老年代。 新生代和老年代有什么特点呢？ 新生代：对象大批会死去，少量存活。 老年代：对象存活率高。因此对于新生代和老年代特点可采用不同回收算法。 新生代：复制算法。复制少量存活对象 老年代：标记-清理 或 标记-整理 算法。标记需回收对象。 如果你有耐心读到此处，恭喜你，已经从理论层面了解了3个垃圾回收算法。我们一起回顾一下其名称： 标记-清除 算法，复制 算法，标记-整理 算法。 那么接下来，在知道了垃圾回收算法后，就要从应用层面去了解垃圾回收算法的应用 （垃圾回收器）。所以，一起看看常见垃圾收集器有什么？:kissing: 常见垃圾收集器异同你说上来吗 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。此次讨论Jdk 7之后 HotSpot 虚拟机包含的几个收集器。 Serial 收集器 新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。 使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值） ​ ​ ParNew 收集器 新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。 使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器 新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%， 这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。 使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）； 使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。 使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效）， 用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。 Serial Old 收集器 老年代收集器，单线程收集器，串行， 使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法， 使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程）， 在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。 CMS 收集器 老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收， 优先使用ParNew+CMS，当用户线程内存不足时，采用备用方案Serial Old收集。 CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) –&gt;预清理(CMS-concurrent-preclean)–&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset) 在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。 CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。 使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。 CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 G1 收集器G1 收集器是一款面向服务器端应用的垃圾收集器，计划未来替代CMS收集器。相比其他GC收集器，G1 具备如下特点： 并行与并发：能充分利用多CPU、多核环境下的硬件优势； 可以并行来缩短”Stop The World”停顿时间； 也可以并发让垃圾收集与用户程序同时进行； ​分代收集：收集范围包括新生代和老年代 ， 能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象； 虽然保留分代概念，但Java堆的内存布局有很大差别； 将整个堆划分为多个大小相等的独立区域（Region）； 新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。 空间整合：结合多种垃圾收集算法，空间整合，不产生碎片。从整体看，是基于标记-整理算法； ​ 从局部（两个Region间）看，是基于复制算法； 这是一种类似火车算法的实现； 都不会产生内存碎片，有利于长时间运行； ​可预测的停顿：低停顿的同时实现高吞吐量， G1除了追求低停顿处，还能建立可预测的停顿时间模型； 可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒； ​ G1 收集器运作大致可划分为如下几个步骤： 初始标记 并发标记 最终标记 筛选回收 应用场景：面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； 在下面的情况时，使用G1可能比CMS好：​ （1）、超过50％的Java堆被活动数据占用；​ （2）、对象分配频率或年代提升频率变化很大；​ （3）、GC停顿时间过长（长于0.5至1秒）。​ 是否一定采用G1呢？也未必：​ 如果现在采用的收集器没有出现问题，不用急着去选择G1；如果应用程序追求低停顿，可以尝试选择G1； 是否代替CMS需要实际场景测试才知道。 内存分配与回收策略你知道吗Java 体系中所提倡的自动内存管理最终可以总结为自动化解决两个问题： 给对象分配内存以及回收分配给对象的内存。 内存回收上面已经讲述，下面一起看看关于对象分配内存的那点事儿。 对象的内存分配，大方向说，就是往堆上分配，对象主要分配到1新生代的Eden区上，若启动本地线程分配缓冲，将按线程优先在TLAB 上分配。少数情况下也可能会直接分配到老年代中。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间进行分配时，虚拟机将进行一次Minor GC。 此处，我们先来了解一下常说的 Minor GC 和 Full GC 有什么不一样吗？ 新生代GC （Minor GC：速度快）：指发生在新生代的垃圾收集动作，因Java 对象大多数都具备招生夕灭特性，所以Minor GC 会非常频繁，一般回收速度也比较快。 老年代GC （Major GC/Full GC：速度慢）：指发生在老年代的GC ，出现了 Major GC，经常会伴随至少一次的Minor GC（但非绝对），Major GC 速度一般比Minor GC 慢10倍以上。 大对象直接进入老年代大对象，大对象，什么标准才是大对象？大对象是指：需要大量连续内存空间的Java对象。最典型大对象是：很长的字符串和数组。大对象对虚拟机来说是一个坏消息，因为出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够连续空间“安置”他们。 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器。那么对象的年龄是怎么计算的呢？ 计算方法：对象在Eden 出生并经过第一次Minor GC后仍然存活，并且能被Survivor 容纳的话，并被移动到Survivor 空间中，则对象年龄设置为1.对象每在Survivor “熬过” 一次Minor GC，年龄+1岁，当他年龄增加到一定程度（默认15岁），就会晋升到老年代中。 动态对象年龄判定如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。关于这句话的理解，请多读两遍就理解了~~~。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC. 总结哇哦，读到此处，是不是有点儿心累，其实我也心累，但相比于此处你获得的知识，是不是感觉一下又阳光明媚了。我们在此处再闭眼回想一下，我们学到的东西： （1）理论层面： 判断对象死活算法：引用计数算法——-可达性分析算法。 垃圾收集算法：标记-清除 算法、复制 算法、标记-整理 算法。 （2）应用层面： 垃圾收集器：balabalabala~~~~。相信你已经知道了。 （3）对象进入内寸分配策略： 首先：Eden区优先 然后：大对象去哪儿？——直接进入老年代。 最后：长期存活对象去哪儿？——先长大到默认年龄15岁，再进入老年代。 到此，我们的学习就结束了，在博文中出现的错误或疑问，欢迎和我交流。 GitHub]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM 垃圾收集器</tag>
        <tag>内存分配策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 Java 的内存模型]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%88%9D%E6%8E%A2-Java-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言上一篇博文中叙述了JVM的内存区域，而与之相似的是Java内存模型。其实JVM与JMM两者之间并不是同一个层次的划分，这两者基本是没有关系的。 但硬要说出点关系，则从变量、主内存、工作内存定义看，对应关系如下： 主内存 ——-&gt; Java堆中对象实例数据部分 工作内存 ——–&gt; 虚拟机栈中部分区域 从更低层次说，对应关系如下： 主内存 ——-&gt; 物理硬件内存 工作内存 ——–&gt; 优先存储于寄存器和高速缓存中（程序运行时主要访问读写的是工作内存） 计算机硬件效率与一致性 ​ 处理器、高速缓存、主内存之间关系 Java 内存模型Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。 定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133[2]）发布后，Java内存模型已经成熟和完善起来了。 主内存和工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示： ​ 线程、主内存、工作内存三者的交互关系 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题后文会讲）。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作。 如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。 注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在后文将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。 注：基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了（仅是描述方式改变了，Java内存模型并没有改变）。 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用 synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。 当一个变量定义为volatile之后，它将具备两种特性 （可见性、禁止指令重排序）。 （1）、保证此变量对所有线程的可见性。 这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因。 12345678910111213141516171819202122232425262728293031public class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; // 等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) Thread.yield(); System.out.println(race); &#125;&#125; 这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？ 问题就出现在自增运算race++ 之中，我们用Javap反编译这段代码后会得到代码，发现只有一行代码的increase（） 方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic 指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic 指令执行后就可能把较小的race值同步回主内存之中。 1234567891011public static void increase（）；Code：Stack=2，Locals=0，Args_size=00：getstatic#13；//Field race：I3：iconst_14：iadd5：putstatic#13；//Field race：I8：returnLineNumberTable：line 14：0line 15：8 客观地说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析。 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 而在像如下的代码清单所示的这类场景就很适合使用volatile变量来控制并发，当shutdown（）方法被调用时，能保证所有线程中执行的doWork（）方法都立即停下来。 123456789volatile boolean shutdownRequested；public void shutdown（）&#123; shutdownRequested=true；&#125;public void doWork（）&#123; while（！shutdownRequested）&#123; //do stuff &#125;&#125; 注：上面这段话到底怎样理解呢？我是这样理解的：其实，Java 内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖于主内存作为传递媒介方式实现可见性。即volitile关键字保证可见性是通过以主内存为媒介进行传递的。 （2）、禁止指令重排序优化。 普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。 上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码清单: 1234567891011121314151617Map configOptions；char[]configText；//此变量必须定义为volatilevolatile boolean initialized=false；//假设以下代码在线程A中执行//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions=new HashMap（）；configText=readConfigFile（fileName）；processConfigOptions（configText,configOptions）；initialized=true；//假设以下代码在线程B中执行//等待initialized为true，代表线程A已经把配置信息初始化完成while（！initialized）&#123; sleep（）；&#125;//使用线程A中初始化好的配置信息doSomethingWithConfig（）； 上述程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义initialized 变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码initialized=true” 被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。 指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，笔者再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。 12345678910111213141516171819public class Singleton &#123; private volatile static Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Singleton.getInstance(); &#125;&#125; 编译后，这段代码对instance变量赋值部分如代码清单 1234567890x01a3de0f：mov$0x3375cdb0，%esi ；……beb0cd75 33 ；&#123;oop（'Singleton'）&#125;0x01a3de14：mov%eax，0x150（%esi） ；……89865001 00000x01a3de1a：shr$0x9，%esi ；……c1ee090x01a3de1d：movb$0x0，0x1104800（%esi） ；……c6860048 1001000x01a3de24：lock addl$0x0，（%esp） ；……f0830424 00 ；*putstatic instance ；-Singleton：getInstance@24 通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150（%esi）这句便是赋值操作）多执行了一个lock addl ＄0x0，（%esp） 操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。这句指令中的addl ＄0x0，（%esp） （把ESP寄存器的值加0）显然是一个空操作（采用这个空操作而不是空操作指令nop是因为IA32手册规定lock 前缀不允许配合nop指令使用），关键在于lock前缀，查询IA32手册，它的作用是所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。 那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10）2与A2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock addl＄0x0，（%esp） 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。 解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 注：上面这段话又怎样理解？volitile关键字它也有使用场景，它的读操作相比于普通变量无区别。但写操作会慢，因为它需要插入许多内存屏障禁止指令重排序。 注：volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复，此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题），这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因。 对于 long 和 double 型变量的特殊规则Java 内存模型对64位数据类型（long 和 double） ：允许虚拟机将没有被volitile关键字修饰的64位数据类型读写操作分两次32位操作来进行。这就是所谓的long和double的非原子性协定 。 再看 Java 内存模型的3个特征 原子性 可见性 有序性 原子性Java 内存模型中尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供更高层次字节码指令monitorenter 和 monitorexit 来隐式使用，这两个字节码指令反应到java代码就是—–synchronized关键字，因此在synchronized块之间的操作也具有原子性。 可见性什么是可见性？即一个线程修改了共享变量值，其他线程能够立即得知这个修改。 如何实现？当然是通过volitile 关键字保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。这也是volitile 变量与普通变量的区别所在！ 还有2个关键字能实现可见性：synchronized 和 final 。 实现机制又是怎样的？简单总结： （1） synchronized （同步块的可见性）：对一个变量进行unlock（多线程操作共享变量，每个线程须lock，unlock该变量。）操作之前，必须先把此变量同步回主内存中（执行store 、write 操作）。 （2） final ：被final 关键字修饰的字段在构造器中一旦初始化完成，且没有把 this 引用传递出去，那么其他线程就能看见final 字段的值。 有序性Java 内存模型有序性 在前面讲解volitile关键字已详细讲解。Java 中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。 前半句指：线程内表现为串行的语义。后半句指：”指令重排序“现象和”工作内存和主内存同步延迟“现象。 Java 语言用volitile和synchronized两个关键字保证线程之间操作有序性。volitile 关键字本身就包含了禁止指令重排序语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得。 介绍完3种特性后是不是发现，synchronized关键字是“万能”的。但是越“万能”的并发控制，通常会伴随着越大的性能影响。在后续博文会说。 总结前面说了这么多，就以下内容： 1、Java 内存模型是怎样的一个工作原理？ 2、内存间是怎么样交互进行信息传递的？ 3、volitile 关键字到底是如何保证一个共享变量的可见性、又如何做到禁止指令重排序，从而保证代码在多线程条件下顺序执行？ 基于以上三个问题，我们做了长篇幅的解释，大体原理可说明说下：1、Java 内存模型原理： 2、共享变量通过以主内存作为媒介，在多线程间进行交互。 3、 （1） 保证可见性：lock 前缀，将使得本CPU的Cache（高速缓存）写入了内存，该写入动作也会引起别的CPU或者别的内核 无效化 （Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。 （2）、禁止指令重排序：增加内存屏障。（lock前缀 ）]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java 内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道题看清 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F05%2F%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8B%E6%B8%85-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[所谓博客，不过孤芳自赏 前言首先，我说的是一道题要看清JVM的类加载机制，所以，我们得先有题呀，一起来看一道经典的面试题： 123456789101112131415161718192021222324252627282930313233343536373839404142class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; //注意此处位置 Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; //注意此处位置 private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; 这道题，看似没有什么差别，但其实，差之毫厘谬以千里，结果会完全不同，但结果究竟是怎么样的呢？我现在还暂时不能告诉你，除非你自己在编译器上运行一下。跟着我一起来看看JVM的类加载机制吧，看完后，你一定会自己说出正确的答案，而且理解其所以然，真真的一道题看清JVM的来世今生！来吧！ 类加载的过程概念虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象） 类的生命周期关于类的生命周期，请记住这句话：加载–&gt;连接–&gt;初始化。 一个类从出生到卸载完会经历以下的生命周期： 类从被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（UnLoading）7个阶段。其中，验证、准备、解析三个阶段又统称为连接（Linking）。可总结为：加载、连接、初始化！ 下面看看这7个过程中（5个阶段）虚拟机进行了哪些动作？ 加载阶段通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 上面这句话是什么意思呢？其实很简单，就是将一个.class 文件通过类加载器，加载到内存中，在方法区保存其类的数据结构，然后在堆中创建该类的对象。该对象又作为访问方法区中该类数据结构（即各种数据）的访问入口。即访问入口是该对象。 即：查找并加载类的二进制数据文件。 连接阶段 验证： 为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证 即：确保被加载类的正确性 准备： 正式为类变量（即static修饰的变量，包括静态代码块）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配 即：为类的静态变量分配内存，并将其初始化为默认值 解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用是二进制数据中引用，直接引用相当于运行期间的指针，指向方法区内存位置。 即：把类的符号引用转换为直接引用 初始化阶段类初始化阶段是类加载过程的最后一步。前面的类加载过程中，除了在加载阶段用户可以使用自定义的类加载器参与外，其余动作完全由虚拟机主导和控制！初始化阶段就是执行类构造器()方法的过程。到了初始化阶段，才真正开始执行类中定义的Java代码（或者说是字节码）！ 静态变量初始化有两种路径： （1）、在静态变量声明处初始化。 （2）、在静态代码块中初始化。 使用阶段开始使用类。 卸载阶段使用完后，卸载类。 关于类加载加载主要是将.class 文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 其中获取.class 文件主要有以下几种方式： ZIP jar（这也是为什么我们在开发中可以使用别人的jar包原因，也是常见加载.class 文件方式） 网络下载 类加载需要完成的三件事情：在加载阶段，JVM需要完成3件事：经历过程如下： 即获取字节流——&gt;方法区——-&gt;Java堆中。 通过类的全限定名获取该类的二进制字节流（即包名+类名）； 将字节流所代表的静态存储结构转化为方法区的运行时数据结构（即将类的数据结构存储于方法区中）； 在堆中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 注：何时会触发类的加载过程，Java虚拟机规范中并没有进行强制约束，而是交给虚拟机的具体实现来自由把握。即然知道了类加载需要完成三件事情，接下来就得知道类加载器是干什么的了。 类加载器虚拟机设计团队把类的加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何获取所需要的类而实现这个动作的模块称为“类加载器”。 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。更通俗的说，也就是：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals()、isAssignableFrom()、isInstance()等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 下面我们用代码来解释一下： 1234567891011121314151617181920212223242526272829303132333435363738394041package stormwangxhu.example;import java.io.IOException;import java.io.InputStream;/** * @author stormwangxhu * @date 2018/04/06 */public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String filename = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(filename); if (inputStream == null) &#123; return super.loadClass(name); &#125; byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; try &#123; Object object=myClassLoader.loadClass("stormwangxhu.example.ClassLoaderTest").newInstance(); System.out.println(object.getClass());//class stormwangxhu.example.ClassLoaderTest System.out.println(object instanceof stormwangxhu.example.ClassLoaderTest);//false &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 我们解释一下上述结果产生的原因： 因为虚拟机种存在了两个ClassLoaderTest的类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然返回false。 若从JVM的角度来看，类加载器可以分为： 启动类加载器(Bootstrap ClassLoader，它负责加载存放在$JAVA_HOME/jre/lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar）。启动类加载器是无法被Java程序直接引用的。很容易可以验证，执行System.out.println(String.class.getClassLoader())打印结果为null) 扩展类加载器(Extension ClassLoader, 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载$JAVA_HOME/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。在jdk1.9中类加载器有所变化！1.9中jdk.internal.loader.ClassLoaders$PlatformClassLoader，称为平台类加载器) 应用程序加载器（系统应用程序类加载器）(Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径ClassPath所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。注意在jdk1.9中，应用程序加载器由jdk.internal.loader.ClassLoaders$AppClassLoader实现) 我们的应用程序都是由这3种类加载器相互配合进行加载的，若有必要，可以加入我们自己定义的类加载器。其中 启动类加载器是由C++语言编写的，其他两个由Java编写。 这些类加载器之间的关系又引出双亲委托机制。 借此机会，我们来看看什么是双亲委托机制！ 双亲委派模型类加载器之间的关系如图所示： 上图所展示的类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 双亲委派模型工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如：类java.lang.Object类存放在$JAVA_HOME/jre/lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这便保证了Object类在程序中的各种类加载器中都是同一个类。相反：若没有使用双亲委派魔性，由各个类加载器自行去加载的话，若用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也无法得到保证，应用程序也将会一片混乱。 此处，我们看看ClassLoader 这个抽象类的双亲委派机制的实现了！该代码都集中在java.lang.ClassLoader 的loadClass 方法之中。 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded，首先，检查请求的类是否已经被加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // 若父加载器抛出ClassNotFoundException，说明父类加载器无法完成加载该类请求 // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // 在父类加载器无法加载的时候， // 再调用自身的findClass来进行类的加载 // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 对照我们上面的测试代码自定义的那个类加载器，如果是实现findClass()而没有实现loadClass()方法，那么加载时候先开始判断它的父类加载器(自定义类加载器的上一级是应用程序类加载器，然后根据双亲委托机制一步一步进行判断加载。最后加载都不成功就会调用findClass()方法来加载，jdk1.2之后官方不提倡实现loadClass()！上面的例子，为了测试两个Class对象不相等，强制实现了loadClass()，因为如果只实现findClass(), 就会被应用类加载器所加载。 注：一般由启动类加载器加载的对象以返回null 来表示该类是由根类加载器加载的。若非根类，则会打印出相关信息。 关于验证验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。虚拟机如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。验证阶段会完成以下4个阶段的检验动作： 文件格式验证 ：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证(是否符合Java语言规范) ：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 字节码验证（确定程序语义合法，符合逻辑） ：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证（确保下一步的解析能正常执行）：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 ​ 关于准备准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段有两个容易混淆的概念，首先，进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，实例变量是在对象实例化的时候分配在Java堆中的。其次这里所说的初始值“通常情况”下是数据类型的零值。 那么问题来了，到底是什么意思呢？其实就是类变量系统为其设置的默认值，而不是程序员通过代码的初始值。 假如我们定义了一个类变量public static int value = 123; 那么，变量value 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value 赋值为123的putstatic 指令是在程序被编译后，存放于类构造器&lt;clinit&gt;() 方法之中，所以把value 赋值为123的动作将在初始化阶段才会执行。 若有个多个静态变量，则依次按顺序分配空间并赋值。 关于各种类型的初始值： 上面说到，在”在通常情况”下初始值为零值，那么相对来说就会有一些“特殊情况”：若类字段的字段属性表中存在ConstantValue 属性，那么在准备阶段变量value 就会被初始化为ConstantValue 属性所指定的值，假设上面类变量定义为： public static final int value=123; 编译时Javac将会为value 生成ConstantValue 属性，在准备阶段虚拟机就会根据ConstantValue 的设置value 赋值为123。 关于解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 对于解析和验证这一块，和读懂Class文件有着密不可分的关系，所以这一块的补充知识会在读懂Class文件字节码之后进行讲解！ 关于初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源。 或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中(static{})的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 ()方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 ()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 注：上面说了这么多，我们脑海中必须有个概念，类变量从加载到初始化被赋值了几次？读到这里，我们应该清楚的认识到，至此，类变量已经被赋值也只能被赋值两次了。 第一次是：连接阶段的准备，赋予类变量系统初始值。 第二次：初始化阶段，赋予程序员给其赋的值。 这里我们再说一下类变量初始化，类变量初始化时按其顺序执行，什么意思呢？看一段代码： 1234567891011121314package stormwangxhu.example;public class staticTest &#123; static int a=1; static &#123; a=2; &#125; static &#123; a=6; &#125; public static void main(String[] args) &#123; System.out.println("a = "+a); &#125;&#125; 这段代码输出结果会是什么呢？1 ？2？还是6。如果你毅然而然的回答了6，那么恭喜你，你真的很6，答案就是6。其原因就是类变量在准备阶段被赋予初始值后，在初始化阶段按其顺序依次向下执行。 类的初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接。 假如类存在志杰的父类，且这个父类还没有被初始化，那就先初始化直接的父类。 假如类中存在初始化语句，那就依次执行这些初始化语句。 那么Java程序对类的使用主要有两种方式，对类的主动使用和被动使用。除了以下几种Java程序主动使用类时需要进行初始化，其余都为被动使用，不会导致类的初始化。 类得初始化时机（主动使用6种） 使用new 创建类的实例； 读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）。 调用类的静态方法。 反射 Class.forName(“xxxx”)。 初始化一个类的子类。 有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 注：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。 （1）、在初始化一个类时，并不会 先初始化它所实现得接口。 （2）、在初始化一个接口时，并不会初始化它的父接口。 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 被标明为启动类的类（即包含main()方法的类）要初始化； 当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上情况称为对一个类进行主动引用，且有且只要以上几种情况（主动使用）需要对类进行初始化。 此处，是时候去解释我们的那道经典面试题了! 面试题答案解析1234567891011121314151617181920212223242526272829303132333435363738394041class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; Singleton输出结果：1 0 原因： 1 、首先执行main中的Singleton singleton = Singleton.getInstance();2、 类的加载：加载类Singleton3、 类的验证4 、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值05、 类的初始化（按照赋值语句进行修改）：执行private static Singleton singleton = new Singleton();执行Singleton的构造器：value1++;value2++; 此时value1，value2均等于1执行public static int value1;public static int value2 = 0;此时value1=1，value2=0 Singleton2输出结果：1 1 原因： 1、 首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2();2、 类的加载：加载类Singleton23、 类的验证4、 类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null,5、 类的初始化（按照赋值语句进行修改）：执行public static int value2 = 0;此时value2=0(value1不变，依然是0);执行private static Singleton singleton = new Singleton();执行Singleton2的构造器：value1++;value2++;此时value1，value2均等于1,即为最后结果 总结上面说了这么多，如果你有耐心一句一句读完，相信你已经对JVM类加载机制有了一定的认识，那么在面试中，此处有什么考点呢？继续看总结。 JVM类加载机制常见面试问题类的生命周期加载—&gt;连接—&gt;初始化—&gt;使用—&gt;卸载 Java类加载器启动类加载器（C++）—&gt;拓展类加载器（Java）—&gt;应用程序类加载器（Java）—&gt;自定义类加载器 他们之间的关系为：双亲委托模型 双亲委派模型工作过程 首先会先查找当前ClassLoader是否加载过此类，有就返回； 如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类； 如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。 作用 共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。 隔离功能，保证java/Android核心类库的纯净和安全，防止恶意加载。 打破双亲委托模型 双亲委派模型的逻辑都在loadClass()中，重写loadClass()，一般是重写findClass()的 系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载 自定义类加载器方法 loadClass(String name,boolean resolve)：根据指定的二进制名称加载类 findClass(String name)： 根据二进制名称来查找类 直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader 在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载 ​ 引起类加载操作的五个行为 遇到new、getstatic、putstatic或invokestatic这四条字节码指令 反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化 虚拟机执行主类的时候(有 main(string[] args)) JDK1.7 动态语言支持 Java对象创建时机 使用new关键字创建对象 使用Class类的newInstance方法(反射机制) 使用Constructor类的newInstance方法(反射机制) 使用Clone方法创建对象 使用(反)序列化机制创建对象 结尾JVM的类加载机制，要我来说，也可能有的地方讲的不太正确，如若有疑问或建议，还请各位大佬私信：牛客用户（StormWangxhu)。 再次特意推荐大家去读周志明老师的《深入理解Java虚拟机》，确实不错。 推荐推荐另外一篇文章： JVM 如何从入门到放弃]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记头条 Java 实习第一面]]></title>
    <url>%2F2018%2F03%2F30%2F%E8%AE%B0%E5%A4%B4%E6%9D%A1Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[人生第一次想要在暑假找一个实习来进行锻炼，奈何心有余力不足，技术学的不扎实，在头条第一面，没考算法的前提下，我顺利的挂了，说起来也是心酸。只好再去学了，我知道面试官只是安慰我，说我还有机会，但我也不会气馁！加油吧，少年！ 1.自我介绍 2.HTTP POST GET 区别(不错) 3.端口的作用(可以) 4.HashMap的实现原理(答得不错)，数据量大的时候查询是否影响效率，查询一个元素的时间复杂度(不行) 5.数据库MySQL索引(不行) 6.前后端数据如何传递 7.Ajax(说了了解过) 8.栈中查找最小元素以及栈结构(不行) 9.冒泡排序时间复杂度(不行) 10.问到了项目图书商城实现了哪些功能，怎么想到要做这个项目的。 11例题，实现一个函数，将一个Map分割出来。 面试总结:基础知识，如常见数据结构知识不够完备，基础知识不扎实。虽然第一面挂了，但是明白了要学习的方面。面试官说，头条里语言不管是哪一门都可以，一些常见的基础知识得掌握，评论我有短期目标，也有长期目标挺不错的。 HTTP 中GET POST请求的区别①get请求用来从服务器上获得资源，而post是用来向服务器提交数据； ②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； ③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式； ④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； ⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。 补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。 链接深入理解HTTP协议]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2017%2F12%2F31%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天在微博上看到了这样的文字，2017年12月31日后，1999年12月31日，也是所有的90后都十八了，成为了法定成年人。突然有一种莫名的感受，晚上的时候朋友圈里便刮起了一阵向自己18岁说再见、晒图片的风暴，诉说着自己18岁的模样。我也去空间找了一张那时的模样。18岁，是一个…emmm怎么说呢，一个转折点吧。18岁，我们高三，决战高考，告别高中岁月，踏入大学校门；18岁，告别青涩的青少年时代，步入成年人行列，慢慢的走向成熟和稳重，但也不失18岁前的单纯和无知，但也更多了一些杂事在心头。总之，18岁，无怨也无悔！ 总结一下2017吧，说起这一年，总体大概就分为两个部分吧，学习和生活。 先来说说生活，我想按时间轴来回顾自己的2017！ 2017年1月：1月初，微信小程序正式上线，很新奇。1月中旬，我在大学的第一个寒假里，选择了去和一群人学习。虽然只有短短10天，但每一天，每一个人，都会带来一份惊讶和感动。认识了一帮好人，做了一些终身难忘的事儿。1月21日，我告别了他们，回家了。记得当时，感触很多。 2017年2月：学习完回家后一直和家人待在一起，期间下了一场雪，很开心，在家的时光，没有学校里的快节奏，过得舒心极了。期间，去了一趟银川，见了见老同学，还和田林学长在六盘山门口吃了个饭，快乐的回忆。2月24日，和勇哥一起来到了学校，开启新的一学期，大一下学期。 2017年3月：这个月，新的一学期开始了。3月18日，我们去烧烤了，大一的我们去的人很多，那天是和张明、马林贵、马小军学长骑行去的，回来的时候，一鼓作气，骑回到了学校，和他们同时回到学校。那时候，校园里花正开，好一番景象！ 2017年4月：3月末4月初的学校，春暖花开。每天晚上，学长学姐我们都约着跑步，绕学校一圈，大概5.5公里，跑下来，一天的疲惫都会感觉被汗水带走了。4月，清明节的第一天，我们便开始了来回长达120公里的骑行。一趟周至，转转水街，一路上骑着自行车跟在大部队的后面听歌溜达，时而追赶，时而说笑，反正我记得，骑行来回的三天，我都会发一条朋友圈。4月29号，和高中的几个同学，我们爬了一趟华山，一路上，酸甜苦辣都有，回来一鼓作气还写了一篇文章，发表在了公众号上。这一月，浪狼的一月。 2017年5月：5月，我们赶了一个小尔迪和涛哥，马总。5月，我们金工实习，磨出属于自己的一个小锤子。5月，有很多一批人，总在凌晨的四点多相互叫着起床，一起吃封斋饭，封莱麦丹月份的斋。记得，一天都没拉下。电话里告诉我父母，说自己的儿子长大了。那些天，每晚的礼拜下，我都祈求着，给我们健康，幸福，知识和快乐，祈求给我们正道和坚忍！5月26日，我们的大四欢送会正式表演，而我和学长张明演出了其中一个节目相声。那天，第一次穿正装，一副老气横秋的大人模样。5月，是一群人的5月。 2017年6月：6月，注定是一个快乐与痛苦并存的6月吧。是一个美丽的季节，是一个难忘的季节，也是一个离别的季节。校园里除了一些燥热外，真的很漂亮。6月11日，和几位学长一起穿着学士服拍了很多照，定格了对他们来说再也回不去的风景。6月21日，是一个尊贵的夜晚，是盖德尔夜，那一晚，又有一群人，直到两点才睡下，做着有意义而有难忘的事情。那一晚，可以说是我内心最平静的一晚，再没有那样平静过了。6月22日，丢了手机，短短几天感觉和世界完全隔绝了一般，无法想象如今没有手机的生活。可能真会错过一个亿！6月28号，我们送走了大四最后几位毕业的学长学姐，可谓打心底里感慨时间流逝的飞快。那时，便告诉自己，一定要珍惜和善待身边的每一位兄弟姐妹，想着和他们在一起的时光将会是大学里最美的回忆。 2017年6月，也是我因为情感而情绪中的低谷。不眠的夜晚，期末考试的焦虑，压得我踹不过气来。喜欢一个女孩，问我为什么，我也说不出来。那时，每晚的心里话和小情绪都写在留言里。后来的后来，再回首，我也说不出来个一二三，喜欢就是喜欢。或许是因为太年轻吧。这一月，读了大冰的一部小说《好吗？好的》，记得在C楼和勇哥一起自习，他在准备期末考试，我却因为情感的低迷，无心学习，却在大冰的书中，找到了一个说不出来的世界。反正很美好吧。 2017年7月：正式进入期末备考阶段，每天都是打了鸡血学习吧。当身心全部都投入到某件事情上时，会发现，那真是一种幸福。7月15日，我大学的四分之一正式画上句号。大一第二学期结束了。 大学以来的第一个暑假，我选择了和学长们去另一个地方学习。这个暑假，真的过的是一个又有意义，又很仓促的的暑假。和学长们在那里认识到的人，学到的东西，还有给人印象和影响，真的深深地刻在了脑海里，感谢他们，感谢那二十几天。也在那二十天里，我才决定放下这一段熬人的感情，或许这是成长的一部分吧！ 2017年8月：我回了趟老家海原，去了趟银川，去了趟舅舅家，一个圈下来，便已匆匆忙忙来到了学校，提前了几天，只是为了参加一个Java培训。最开始的几天，感觉哇真好，还能免费培训，每天朝九晚五挤公交，中午便在那个培训地点的清真窗口上吃一顿，一种上班人的感受在心底已开始泛滥。后面的某一天，负责人把我叫去聊天，聊了很久。说到底，要交一万多元钱，保证可以怎样怎样，回来后，第二天再也没去，一觉睡到天荒！去你的小杰瑞，我哪儿有钱给你，自身难保呢~。8月31日，古尔邦节，在这边过的。一个繁忙的8月，仓促的8月。 2017年9月：又是9月，不在是单纯的别人的学弟学妹了，我们迎来了我们的学弟学妹。那一天，是我最累的一天，也是这次来西安后，做的第一件有意义的事情了。接了一整天的学弟学妹，记得接的第一个学弟是王金川，和父母提前一天过来。转了西安，游玩了古城。从图书馆出来的我和他相遇到图书馆和情人坑的那条街上，是田鸿才学长叫出去的。接的最后一个学弟是马伯谦，深夜十点了，下着毛毛细雨，在外面等他从航天城打的过来。接他回到我宿舍，安排好后，已不记得后续的事情了，或许已经睡着了。9月，还读了大冰的新书《我不》，依旧感觉很好。 2017年10月：这个十一，回家帮家人搬玉米，苦中作乐，乐在其中！10月21日，骑行去三星公园一起在秋天的落叶中，放松自我。10月24日，程序员的节日。10月25号，报名了西安城墙彩虹跑。十月，感觉很快的一个月。 2017年11月：11月，这个月，主打题是学长学姐的经验分享，那几天，有国创，有学长学姐分享完要做的微信推送。当我们三个把国创项目立项书交上去后的前一天晚上，第一次在C楼过夜，第一次睡到了桌子上，第二天清晨被发现，让我们下不为例。交上去的第二天，我便瘫痪了，身体累到不行，别人都说，怎么憔悴了不少…。其实，会发现，一件事情结果如何先不管，这个过程真的很难忘。这个月在微信公众号推送了好几篇，学长学姐们的经验也细细品读，希望自己在学习技术的路上少走些弯路。在自己搭建的博客上，我写下对自己的一句话：虽然有时候我走的很慢，但我相信自己可以走得很远！最后那几天，每天都固定在C楼一个教室，很充实。真心希望所有人的努力都会有相应的回报。 愿你有好运气，如果没有，愿你在不幸中学会慈悲。 愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。 感谢和我一直在一起的几位学长学姐一直的陪伴。 2017年12月：终于到了2017年，写到了12月，2017就这样被写到了结束。12月，考了四级，却把翻译内容写在了写作文的地方，被提前收走了，写到最后的翻译处才发现，自己写错了。考场的我在心里对自己笑了一万遍。那就来年再战吧！ 昨天晚上，组织了一次2017年末包饺子活动，感谢大二的这帮兄弟姐妹们。很感谢！忙了一天，理应睡的很香，但却失眠了。发表了2017年的倒数第二个微博，想对自己说一些话。 总之，2017年，生活和学习都在前进中，也在前进中，不断的成长，认识自己，认识这个世界。真的，成长了很多。 要想用一句话总结的话，我想那就是：问心无愧吧 2018年，希望自己在学习技术的道路上，可以更加的投入，逼自己一把。活成为自己想成为的模样。生活中，不再奢求谁可以陪伴你，聊天散步谈心情，发现每个人都有自己的生活轨迹，每个人都有自己的事情可做，终究要学会习惯一个人也可以活得很潇洒。总之，2018，希望我关心的和关心我的人，都能够幸福，快乐，充实吧，将自己活得更精致一些！ 你好2018！再见，再也不见，2017！ -----2017年12月30号晚 小虎|诉说17，规划18]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
