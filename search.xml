<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F09%2F19%2Fhello%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[一道题看清 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F05%2F%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8B%E6%B8%85-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言首先，我说的是一道题要看清JVM的类加载机制，所以，我们得先有题呀，一起来看一道经典的面试题： 123456789101112131415161718192021222324252627282930313233343536373839404142class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; //注意此处位置 Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; //注意此处位置 private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; 这道题，看似没有什么差别，但其实，差之毫厘谬以千里，结果会完全不同，但结果究竟是怎么样的呢？我现在还暂时不能告诉你，除非你自己在编译器上运行一下。跟着我一起来看看JVM的类加载机制吧，看完后，你一定会自己说出正确的答案，而且理解其所以然，真真的一道题看清JVM的来世今生！来吧！ 类加载的过程概念虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象） 类的生命周期关于类的生命周期，请记住这句话：加载–&gt;连接–&gt;初始化。 一个类从出生到卸载完会经历以下的生命周期： 类从被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（UnLoading）7个阶段。其中，验证、准备、解析三个阶段又统称为连接（Linking）。可总结为：加载、连接、初始化！ 下面看看这7个过程中（5个阶段）虚拟机进行了哪些动作？ 加载阶段通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 上面这句话是什么意思呢？其实很简单，就是将一个.class 文件通过类加载器，加载到内存中，在方法区保存其类的数据结构，然后在堆中创建该类的对象。该对象又作为访问方法区中该类数据结构（即各种数据）的访问入口。即访问入口是该对象。 即：查找并加载类的二进制数据文件。 连接阶段 验证： 为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证 即：确保被加载类的正确性 准备： 正式为类变量（即static修饰的变量，包括静态代码块）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配 即：为类的静态变量分配内存，并将其初始化为默认值 解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用是二进制数据中引用，直接引用相当于运行期间的指针，指向方法区内存位置。 即：把类的符号引用转换为直接引用 初始化阶段类初始化阶段是类加载过程的最后一步。前面的类加载过程中，除了在加载阶段用户可以使用自定义的类加载器参与外，其余动作完全由虚拟机主导和控制！初始化阶段就是执行类构造器()方法的过程。到了初始化阶段，才真正开始执行类中定义的Java代码（或者说是字节码）！ 静态变量初始化有两种路径： （1）、在静态变量声明处初始化。 （2）、在静态代码块中初始化。 使用阶段开始使用类。 卸载阶段使用完后，卸载类。 关于类加载加载主要是将.class 文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 其中获取.class 文件主要有以下几种方式： ZIP jar（这也是为什么我们在开发中可以使用别人的jar包原因，也是常见加载.class 文件方式） 网络下载 类加载需要完成的三件事情：在加载阶段，JVM需要完成3件事：经历过程如下： 即获取字节流——&gt;方法区——-&gt;Java堆中。 通过类的全限定名获取该类的二进制字节流（即包名+类名）； 将字节流所代表的静态存储结构转化为方法区的运行时数据结构（即将类的数据结构存储于方法区中）； 在堆中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 注：何时会触发类的加载过程，Java虚拟机规范中并没有进行强制约束，而是交给虚拟机的具体实现来自由把握。即然知道了类加载需要完成三件事情，接下来就得知道类加载器是干什么的了。 类加载器虚拟机设计团队把类的加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何获取所需要的类而实现这个动作的模块称为“类加载器”。 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。更通俗的说，也就是：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals()、isAssignableFrom()、isInstance()等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 下面我们用代码来解释一下： 1234567891011121314151617181920212223242526272829303132333435363738394041package stormwangxhu.example;import java.io.IOException;import java.io.InputStream;/** * @author stormwangxhu * @date 2018/04/06 */public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String filename = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(filename); if (inputStream == null) &#123; return super.loadClass(name); &#125; byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; try &#123; Object object=myClassLoader.loadClass("stormwangxhu.example.ClassLoaderTest").newInstance(); System.out.println(object.getClass());//class stormwangxhu.example.ClassLoaderTest System.out.println(object instanceof stormwangxhu.example.ClassLoaderTest);//false &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 我们解释一下上述结果产生的原因： 因为虚拟机种存在了两个ClassLoaderTest的类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然返回false。 若从JVM的角度来看，类加载器可以分为： 启动类加载器(Bootstrap ClassLoader，它负责加载存放在$JAVA_HOME/jre/lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar）。启动类加载器是无法被Java程序直接引用的。很容易可以验证，执行System.out.println(String.class.getClassLoader())打印结果为null) 扩展类加载器(Extension ClassLoader, 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载$JAVA_HOME/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。在jdk1.9中类加载器有所变化！1.9中jdk.internal.loader.ClassLoaders$PlatformClassLoader，称为平台类加载器) 应用程序加载器（系统应用程序类加载器）(Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径ClassPath所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。注意在jdk1.9中，应用程序加载器由jdk.internal.loader.ClassLoaders$AppClassLoader实现) 我们的应用程序都是由这3种类加载器相互配合进行加载的，若有必要，可以加入我们自己定义的类加载器。其中 启动类加载器是由C++语言编写的，其他两个由Java编写。 这些类加载器之间的关系又引出双亲委托机制。 借此机会，我们来看看什么是双亲委托机制！ 双亲委派模型类加载器之间的关系如图所示： 上图所展示的类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 双亲委派模型工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如：类java.lang.Object类存放在$JAVA_HOME/jre/lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这便保证了Object类在程序中的各种类加载器中都是同一个类。相反：若没有使用双亲委派魔性，由各个类加载器自行去加载的话，若用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也无法得到保证，应用程序也将会一片混乱。 此处，我们看看ClassLoader 这个抽象类的双亲委派机制的实现了！该代码都集中在java.lang.ClassLoader 的loadClass 方法之中。 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded，首先，检查请求的类是否已经被加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // 若父加载器抛出ClassNotFoundException，说明父类加载器无法完成加载该类请求 // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // 在父类加载器无法加载的时候， // 再调用自身的findClass来进行类的加载 // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 对照我们上面的测试代码自定义的那个类加载器，如果是实现findClass()而没有实现loadClass()方法，那么加载时候先开始判断它的父类加载器(自定义类加载器的上一级是应用程序类加载器，然后根据双亲委托机制一步一步进行判断加载。最后加载都不成功就会调用findClass()方法来加载，jdk1.2之后官方不提倡实现loadClass()！上面的例子，为了测试两个Class对象不相等，强制实现了loadClass()，因为如果只实现findClass(), 就会被应用类加载器所加载。 注：一般由启动类加载器加载的对象以返回null 来表示该类是由根类加载器加载的。若非根类，则会打印出相关信息。 关于验证验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。虚拟机如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。验证阶段会完成以下4个阶段的检验动作： 文件格式验证 ：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证(是否符合Java语言规范) ：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 字节码验证（确定程序语义合法，符合逻辑） ：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证（确保下一步的解析能正常执行）：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 ​ 关于准备准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段有两个容易混淆的概念，首先，进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，实例变量是在对象实例化的时候分配在Java堆中的。其次这里所说的初始值“通常情况”下是数据类型的零值。 那么问题来了，到底是什么意思呢？其实就是类变量系统为其设置的默认值，而不是程序员通过代码的初始值。 假如我们定义了一个类变量public static int value = 123; 那么，变量value 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value 赋值为123的putstatic 指令是在程序被编译后，存放于类构造器&lt;clinit&gt;() 方法之中，所以把value 赋值为123的动作将在初始化阶段才会执行。 若有个多个静态变量，则依次按顺序分配空间并赋值。 关于各种类型的初始值： 上面说到，在”在通常情况”下初始值为零值，那么相对来说就会有一些“特殊情况”：若类字段的字段属性表中存在ConstantValue 属性，那么在准备阶段变量value 就会被初始化为ConstantValue 属性所指定的值，假设上面类变量定义为： public static final int value=123; 编译时Javac将会为value 生成ConstantValue 属性，在准备阶段虚拟机就会根据ConstantValue 的设置value 赋值为123。 关于解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 对于解析和验证这一块，和读懂Class文件有着密不可分的关系，所以这一块的补充知识会在读懂Class文件字节码之后进行讲解！ 关于初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源。 或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中(static{})的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 ()方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 ()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 注：上面说了这么多，我们脑海中必须有个概念，类变量从加载到初始化被赋值了几次？读到这里，我们应该清楚的认识到，至此，类变量已经被赋值也只能被赋值两次了。 第一次是：连接阶段的准备，赋予类变量系统初始值。 第二次：初始化阶段，赋予程序员给其赋的值。 这里我们再说一下类变量初始化，类变量初始化时按其顺序执行，什么意思呢？看一段代码： 1234567891011121314package stormwangxhu.example;public class staticTest &#123; static int a=1; static &#123; a=2; &#125; static &#123; a=6; &#125; public static void main(String[] args) &#123; System.out.println("a = "+a); &#125;&#125; 这段代码输出结果会是什么呢？1 ？2？还是6。如果你毅然而然的回答了6，那么恭喜你，你真的很6，答案就是6。其原因就是类变量在准备阶段被赋予初始值后，在初始化阶段按其顺序依次向下执行。 类的初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接。 假如类存在志杰的父类，且这个父类还没有被初始化，那就先初始化直接的父类。 假如类中存在初始化语句，那就依次执行这些初始化语句。 那么Java程序对类的使用主要有两种方式，对类的主动使用和被动使用。除了以下几种Java程序主动使用类时需要进行初始化，其余都为被动使用，不会导致类的初始化。 类得初始化时机（主动使用6种） 使用new 创建类的实例； 读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）。 调用类的静态方法。 反射 Class.forName(“xxxx”)。 初始化一个类的子类。 有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 注：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。 （1）、在初始化一个类时，并不会 先初始化它所实现得接口。 （2）、在初始化一个接口时，并不会初始化它的父接口。 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 被标明为启动类的类（即包含main()方法的类）要初始化； 当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上情况称为对一个类进行主动引用，且有且只要以上几种情况（主动使用）需要对类进行初始化。 此处，是时候去解释我们的那道经典面试题了! 面试题答案解析1234567891011121314151617181920212223242526272829303132333435363738394041class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; Singleton输出结果：1 0 原因： 1 、首先执行main中的Singleton singleton = Singleton.getInstance();2、 类的加载：加载类Singleton3、 类的验证4 、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值05、 类的初始化（按照赋值语句进行修改）：执行private static Singleton singleton = new Singleton();执行Singleton的构造器：value1++;value2++; 此时value1，value2均等于1执行public static int value1;public static int value2 = 0;此时value1=1，value2=0 Singleton2输出结果：1 1 原因： 1、 首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2();2、 类的加载：加载类Singleton23、 类的验证4、 类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null,5、 类的初始化（按照赋值语句进行修改）：执行public static int value2 = 0;此时value2=0(value1不变，依然是0);执行private static Singleton singleton = new Singleton();执行Singleton2的构造器：value1++;value2++;此时value1，value2均等于1,即为最后结果 总结上面说了这么多，如果你有耐心一句一句读完，相信你已经对JVM类加载机制有了一定的认识，那么在面试中，此处有什么考点呢？继续看总结。 JVM类加载机制常见面试问题类的生命周期加载—&gt;连接—&gt;初始化—&gt;使用—&gt;卸载 Java类加载器启动类加载器（C++）—&gt;拓展类加载器（Java）—&gt;应用程序类加载器（Java）—&gt;自定义类加载器 他们之间的关系为：双亲委托模型 双亲委派模型工作过程 首先会先查找当前ClassLoader是否加载过此类，有就返回； 如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类； 如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。 作用 共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。 隔离功能，保证java/Android核心类库的纯净和安全，防止恶意加载。 打破双亲委托模型 双亲委派模型的逻辑都在loadClass()中，重写loadClass()，一般是重写findClass()的 系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载 自定义类加载器方法 loadClass(String name,boolean resolve)：根据指定的二进制名称加载类 findClass(String name)： 根据二进制名称来查找类 直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader 在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载 ​ 引起类加载操作的五个行为 遇到new、getstatic、putstatic或invokestatic这四条字节码指令 反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化 虚拟机执行主类的时候(有 main(string[] args)) JDK1.7 动态语言支持 Java对象创建时机 使用new关键字创建对象 使用Class类的newInstance方法(反射机制) 使用Constructor类的newInstance方法(反射机制) 使用Clone方法创建对象 使用(反)序列化机制创建对象 结尾JVM的类加载机制，要我来说，也可能有的地方讲的不太正确，如若有疑问或建议，还请各位大佬私信：牛客用户（StormWangxhu)。 再次特意推荐大家去读周志明老师的《深入理解Java虚拟机》，确实不错。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
      </tags>
  </entry>
</search>
